/* tslint:disable */
/* eslint-disable */
/**
 * Sofia Api
 * Api principal do sistema Sofia.
 *
 * The version of the OpenAPI document: 0.0.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AiChatFeatureSpecificationEntity
 */
export interface AiChatFeatureSpecificationEntity {
    /**
     * 
     * @type {string}
     * @memberof AiChatFeatureSpecificationEntity
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof AiChatFeatureSpecificationEntity
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof AiChatFeatureSpecificationEntity
     */
    'subscriptionProductId': string;
}
/**
 * 
 * @export
 * @interface BankAccountEntity
 */
export interface BankAccountEntity {
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'bankConnectionId': string;
    /**
     * 
     * @type {BankConnectionEntity}
     * @memberof BankAccountEntity
     */
    'bankConnection': BankConnectionEntity;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'providerAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof BankAccountEntity
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof BankAccountEntity
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'currencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankAccountsBalanceReportEntity
 */
export interface BankAccountsBalanceReportEntity {
    /**
     * 
     * @type {Array<BankAccountsBalanceReportItemEntity>}
     * @memberof BankAccountsBalanceReportEntity
     */
    'items': Array<BankAccountsBalanceReportItemEntity>;
    /**
     * 
     * @type {Array<BankAccountEntity>}
     * @memberof BankAccountsBalanceReportEntity
     */
    'bankAccounts': Array<BankAccountEntity>;
}
/**
 * 
 * @export
 * @interface BankAccountsBalanceReportItemEntity
 */
export interface BankAccountsBalanceReportItemEntity {
    /**
     * 
     * @type {number}
     * @memberof BankAccountsBalanceReportItemEntity
     */
    'totalBalance': number;
    /**
     * 
     * @type {string}
     * @memberof BankAccountsBalanceReportItemEntity
     */
    'currencyCode': string;
}
/**
 * 
 * @export
 * @interface BankConnectionEntity
 */
export interface BankConnectionEntity {
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'workspaceId': string;
    /**
     * 
     * @type {boolean}
     * @memberof BankConnectionEntity
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'providerItemId': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'historyRange': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'connectorId': string;
    /**
     * 
     * @type {BankConnectorEntity}
     * @memberof BankConnectionEntity
     */
    'connector': BankConnectorEntity;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankConnectionWithAccountsEntity
 */
export interface BankConnectionWithAccountsEntity {
    /**
     * 
     * @type {string}
     * @memberof BankConnectionWithAccountsEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionWithAccountsEntity
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionWithAccountsEntity
     */
    'workspaceId': string;
    /**
     * 
     * @type {Array<PlainBankAccountEntity>}
     * @memberof BankConnectionWithAccountsEntity
     */
    'accounts': Array<PlainBankAccountEntity>;
    /**
     * 
     * @type {boolean}
     * @memberof BankConnectionWithAccountsEntity
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionWithAccountsEntity
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionWithAccountsEntity
     */
    'providerItemId': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionWithAccountsEntity
     */
    'historyRange': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionWithAccountsEntity
     */
    'connectorId': string;
    /**
     * 
     * @type {BankConnectorEntity}
     * @memberof BankConnectionWithAccountsEntity
     */
    'connector': BankConnectorEntity;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionWithAccountsEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionWithAccountsEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankConnectorEntity
 */
export interface BankConnectorEntity {
    /**
     * 
     * @type {string}
     * @memberof BankConnectorEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectorEntity
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectorEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectorEntity
     */
    'institutionUrl': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectorEntity
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectorEntity
     */
    'primaryColor': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectorEntity
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectorEntity
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectorEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectorEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankTransactionCategoryEntity
 */
export interface BankTransactionCategoryEntity {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntity
     */
    'parentId'?: string;
    /**
     * 
     * @type {Array<BankTransactionCategoryPlainEntity>}
     * @memberof BankTransactionCategoryEntity
     */
    'path': Array<BankTransactionCategoryPlainEntity>;
    /**
     * 
     * @type {Array<BankTransactionCategoryPlainEntity>}
     * @memberof BankTransactionCategoryEntity
     */
    'children': Array<BankTransactionCategoryPlainEntity>;
}
/**
 * 
 * @export
 * @interface BankTransactionCategoryPlainEntity
 */
export interface BankTransactionCategoryPlainEntity {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryPlainEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryPlainEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryPlainEntity
     */
    'parentId'?: string;
}
/**
 * 
 * @export
 * @interface BankTransactionCostCenterEntity
 */
export interface BankTransactionCostCenterEntity {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCostCenterEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCostCenterEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCostCenterEntity
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCostCenterEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCostCenterEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankTransactionCreditCardMetadataEntity
 */
export interface BankTransactionCreditCardMetadataEntity {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCreditCardMetadataEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCreditCardMetadataEntity
     */
    'transactionId': string;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionCreditCardMetadataEntity
     */
    'installmentNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionCreditCardMetadataEntity
     */
    'totalInstallments'?: number;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionCreditCardMetadataEntity
     */
    'totalAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionCreditCardMetadataEntity
     */
    'payeeMCC'?: number;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCreditCardMetadataEntity
     */
    'cardNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCreditCardMetadataEntity
     */
    'billId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCreditCardMetadataEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCreditCardMetadataEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankTransactionEntity
 */
export interface BankTransactionEntity {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'accountId': string;
    /**
     * 
     * @type {BankAccountEntity}
     * @memberof BankTransactionEntity
     */
    'account': BankAccountEntity;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'provider': BankTransactionEntityProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'providerTransactionId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'originalDescription': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'postedDate': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'competencyDate': string;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionEntity
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'type': BankTransactionEntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'status': BankTransactionEntityStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'providerCategoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'providerCategoryName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'categoryId'?: string;
    /**
     * 
     * @type {BankTransactionCategoryPlainEntity}
     * @memberof BankTransactionEntity
     */
    'category'?: BankTransactionCategoryPlainEntity;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'costCenterId'?: string;
    /**
     * 
     * @type {BankTransactionCostCenterEntity}
     * @memberof BankTransactionEntity
     */
    'costCenter'?: BankTransactionCostCenterEntity;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'paymentDataId'?: string;
    /**
     * 
     * @type {BankTransactionPaymentDataEntity}
     * @memberof BankTransactionEntity
     */
    'paymentData'?: BankTransactionPaymentDataEntity;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'creditCardMetadataId'?: string;
    /**
     * 
     * @type {BankTransactionCreditCardMetadataEntity}
     * @memberof BankTransactionEntity
     */
    'creditCardMetadata'?: BankTransactionCreditCardMetadataEntity;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'bestGuessCategoryId'?: string;
    /**
     * 
     * @type {BankTransactionCategoryPlainEntity}
     * @memberof BankTransactionEntity
     */
    'bestGuessCategory'?: BankTransactionCategoryPlainEntity;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'ignoredAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'confirmedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'updatedAt': string;
}

export const BankTransactionEntityProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type BankTransactionEntityProviderEnum = typeof BankTransactionEntityProviderEnum[keyof typeof BankTransactionEntityProviderEnum];
export const BankTransactionEntityTypeEnum = {
    Debit: 'DEBIT',
    Credit: 'CREDIT'
} as const;

export type BankTransactionEntityTypeEnum = typeof BankTransactionEntityTypeEnum[keyof typeof BankTransactionEntityTypeEnum];
export const BankTransactionEntityStatusEnum = {
    Pending: 'PENDING',
    Posted: 'POSTED'
} as const;

export type BankTransactionEntityStatusEnum = typeof BankTransactionEntityStatusEnum[keyof typeof BankTransactionEntityStatusEnum];

/**
 * 
 * @export
 * @interface BankTransactionPaymentDataEntity
 */
export interface BankTransactionPaymentDataEntity {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'transactionId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'payeerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'payerBranchNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'payerAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'payerRoutingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'payerRoutingNumberISPB'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'payerDocumentNumberType'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'payerDocumentNumberValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'receiverName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'receiverBranchNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'receiverAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'receiverRoutingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'receiverRoutingNumberISPB'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'receiverDocumentNumberType'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'receiverDocumentNumberValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'paymentMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'referenceNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'receiverReferenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionPaymentDataEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankTransactionsPageEntity
 */
export interface BankTransactionsPageEntity {
    /**
     * 
     * @type {number}
     * @memberof BankTransactionsPageEntity
     */
    'pageIndex': number;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionsPageEntity
     */
    'pageSize': number;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionsPageEntity
     */
    'totalItems': number;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionsPageEntity
     */
    'totalPages': number;
    /**
     * 
     * @type {Array<BankTransactionEntity>}
     * @memberof BankTransactionsPageEntity
     */
    'items': Array<BankTransactionEntity>;
}
/**
 * 
 * @export
 * @interface CashFlowByCategoryReportEntity
 */
export interface CashFlowByCategoryReportEntity {
    /**
     * 
     * @type {Array<CashFlowByCategoryReportItemEntity>}
     * @memberof CashFlowByCategoryReportEntity
     */
    'items': Array<CashFlowByCategoryReportItemEntity>;
}
/**
 * 
 * @export
 * @interface CashFlowByCategoryReportItemEntity
 */
export interface CashFlowByCategoryReportItemEntity {
    /**
     * 
     * @type {string}
     * @memberof CashFlowByCategoryReportItemEntity
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowByCategoryReportItemEntity
     */
    'categoryName': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowByCategoryReportItemEntity
     */
    'absoluteValue': number;
    /**
     * 
     * @type {number}
     * @memberof CashFlowByCategoryReportItemEntity
     */
    'percentage': number;
}
/**
 * 
 * @export
 * @interface CashFlowReportDailyItemEntity
 */
export interface CashFlowReportDailyItemEntity {
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportDailyItemEntity
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportDailyItemEntity
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportDailyItemEntity
     */
    'dayOfYear': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportDailyItemEntity
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportDailyItemEntity
     */
    'minDate': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportDailyItemEntity
     */
    'maxDate': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportDailyItemEntity
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CashFlowReportEntity
 */
export interface CashFlowReportEntity {
    /**
     * 
     * @type {Array<CashFlowReportDailyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'dailyBalanceItems': Array<CashFlowReportDailyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportDailyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'dailyPostedIncomeItems': Array<CashFlowReportDailyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportDailyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'dailyCompetencyIncomeItems': Array<CashFlowReportDailyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportDailyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'dailyPostedOutcomeItems': Array<CashFlowReportDailyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportDailyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'dailyCompetencyOutcomeItems': Array<CashFlowReportDailyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportWeeklyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'weeklyBalanceItems': Array<CashFlowReportWeeklyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportWeeklyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'weeklyPostedIncomeItems': Array<CashFlowReportWeeklyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportWeeklyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'weeklyCompetencyIncomeItems': Array<CashFlowReportWeeklyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportWeeklyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'weeklyPostedOutcomeItems': Array<CashFlowReportWeeklyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportWeeklyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'weeklyCompetencyOutcomeItems': Array<CashFlowReportWeeklyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportMonthlyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'monthlyBalanceItems': Array<CashFlowReportMonthlyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportMonthlyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'monthlyPostedIncomeItems': Array<CashFlowReportMonthlyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportMonthlyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'monthlyCompetencyIncomeItems': Array<CashFlowReportMonthlyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportMonthlyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'monthlyPostedOutcomeItems': Array<CashFlowReportMonthlyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportMonthlyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'monthlyCompetencyOutcomeItems': Array<CashFlowReportMonthlyItemEntity>;
}
/**
 * 
 * @export
 * @interface CashFlowReportMonthlyItemEntity
 */
export interface CashFlowReportMonthlyItemEntity {
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'month': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'minDate': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'maxDate': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CashFlowReportWeeklyItemEntity
 */
export interface CashFlowReportWeeklyItemEntity {
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'week': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'minDate': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'maxDate': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CategoryGuessDto
 */
export interface CategoryGuessDto {
    /**
     * 
     * @type {string}
     * @memberof CategoryGuessDto
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryGuessDto
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof CategoryGuessDto
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof CategoryGuessDto
     */
    'origin': string;
}
/**
 * 
 * @export
 * @interface CheckEmailInUseRequestDto
 */
export interface CheckEmailInUseRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CheckEmailInUseRequestDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface CheckoutSessionEntity
 */
export interface CheckoutSessionEntity {
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionEntity
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ConnectionFeatureSpecificationEntity
 */
export interface ConnectionFeatureSpecificationEntity {
    /**
     * 
     * @type {string}
     * @memberof ConnectionFeatureSpecificationEntity
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectionFeatureSpecificationEntity
     */
    'unlimited': boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnectionFeatureSpecificationEntity
     */
    'max'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectionFeatureSpecificationEntity
     */
    'subscriptionProductId': string;
}
/**
 * 
 * @export
 * @interface CreateBankTransactionCostCenterRequestDto
 */
export interface CreateBankTransactionCostCenterRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateBankTransactionCostCenterRequestDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateBankAccountRequestDto
 */
export interface CreateOrUpdateBankAccountRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'bankConnectionId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'providerAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'currencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateBankConnectionRequestDto
 */
export interface CreateOrUpdateBankConnectionRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankConnectionRequestDto
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankConnectionRequestDto
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankConnectionRequestDto
     */
    'providerItemId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankConnectionRequestDto
     */
    'providerConnectorId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankConnectionRequestDto
     */
    'historyRange': string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateBankTransactionsInBulkItemDto
 */
export interface CreateOrUpdateBankTransactionsInBulkItemDto {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'providerTransactionId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'postedDate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'competencyDate': string;
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'providerCategoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'providerCategoryName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'costCenterId'?: string;
    /**
     * 
     * @type {PaymentDataDto}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'paymentData': PaymentDataDto;
    /**
     * 
     * @type {CreditCardMetadataDto}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'creditCardMetadata': CreditCardMetadataDto;
    /**
     * 
     * @type {Array<CategoryGuessDto>}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'categoryGuesses': Array<CategoryGuessDto>;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkItemDto
     */
    'bestGuessCategoryId': string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateBankTransactionsInBulkRequestDto
 */
export interface CreateOrUpdateBankTransactionsInBulkRequestDto {
    /**
     * 
     * @type {Array<CreateOrUpdateBankTransactionsInBulkItemDto>}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDto
     */
    'items': Array<CreateOrUpdateBankTransactionsInBulkItemDto>;
}
/**
 * 
 * @export
 * @interface CreatePluggyConnectTokenRequestDto
 */
export interface CreatePluggyConnectTokenRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePluggyConnectTokenRequestDto
     */
    'itemId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePluggyConnectTokenRequestDto
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePluggyConnectTokenRequestDto
     */
    'historyRange': string;
}
/**
 * 
 * @export
 * @interface CreateProfileRequestDto
 */
export interface CreateProfileRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequestDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequestDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequestDto
     */
    'birthDate': string;
}
/**
 * 
 * @export
 * @interface CreateStripeCheckoutSessionRequestDto
 */
export interface CreateStripeCheckoutSessionRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateStripeCheckoutSessionRequestDto
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateStripeCheckoutSessionRequestDto
     */
    'priceId': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateStripeCheckoutSessionRequestDto
     */
    'isTrial': boolean;
}
/**
 * 
 * @export
 * @interface CreateWorkspaceRequestDto
 */
export interface CreateWorkspaceRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceRequestDto
     */
    'prettyId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceRequestDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceRequestDto
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface CredentialsEntity
 */
export interface CredentialsEntity {
    /**
     * 
     * @type {string}
     * @memberof CredentialsEntity
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialsEntity
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialsEntity
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface CreditCardMetadataDto
 */
export interface CreditCardMetadataDto {
    /**
     * 
     * @type {number}
     * @memberof CreditCardMetadataDto
     */
    'installmentNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditCardMetadataDto
     */
    'totalInstallments'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditCardMetadataDto
     */
    'totalAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreditCardMetadataDto
     */
    'payeeMCC'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreditCardMetadataDto
     */
    'cardNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditCardMetadataDto
     */
    'billId'?: string;
}
/**
 * 
 * @export
 * @interface EmailInUseEntity
 */
export interface EmailInUseEntity {
    /**
     * 
     * @type {string}
     * @memberof EmailInUseEntity
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof EmailInUseEntity
     */
    'inUse': boolean;
}
/**
 * 
 * @export
 * @interface ErrorEntity
 */
export interface ErrorEntity {
    /**
     * 
     * @type {string}
     * @memberof ErrorEntity
     */
    'fieldId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ErrorEntity
     */
    'messages': Array<string>;
}
/**
 * 
 * @export
 * @interface ExceptionResponseEntity
 */
export interface ExceptionResponseEntity {
    /**
     * 
     * @type {number}
     * @memberof ExceptionResponseEntity
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ExceptionResponseEntity
     */
    'message': string;
    /**
     * 
     * @type {Array<ErrorEntity>}
     * @memberof ExceptionResponseEntity
     */
    'errors': Array<ErrorEntity>;
}
/**
 * 
 * @export
 * @interface FinancialTransactionsFeatureSpecificationEntity
 */
export interface FinancialTransactionsFeatureSpecificationEntity {
    /**
     * 
     * @type {string}
     * @memberof FinancialTransactionsFeatureSpecificationEntity
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof FinancialTransactionsFeatureSpecificationEntity
     */
    'unlimited': boolean;
    /**
     * 
     * @type {number}
     * @memberof FinancialTransactionsFeatureSpecificationEntity
     */
    'maxPerMonth'?: number;
    /**
     * 
     * @type {string}
     * @memberof FinancialTransactionsFeatureSpecificationEntity
     */
    'subscriptionProductId': string;
}
/**
 * 
 * @export
 * @interface ParcialUpdateWorkspaceRequestDto
 */
export interface ParcialUpdateWorkspaceRequestDto {
    /**
     * 
     * @type {string}
     * @memberof ParcialUpdateWorkspaceRequestDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PaymentDataDto
 */
export interface PaymentDataDto {
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'payerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'payerBranchNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'payerAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'payerRoutingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'payerRoutingNumberISPB'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'payerDocumentNumberType'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'payerDocumentNumberValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'receiverName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'receiverBranchNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'receiverAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'receiverRoutingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'receiverRoutingNumberISPB'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'receiverDocumentNumberType'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'receiverDocumentNumberValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'paymentMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'referenceNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDataDto
     */
    'receiverReferenceId'?: string;
}
/**
 * 
 * @export
 * @interface PaymentsManagerProductDataEntity
 */
export interface PaymentsManagerProductDataEntity {
    /**
     * 
     * @type {string}
     * @memberof PaymentsManagerProductDataEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsManagerProductDataEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentsManagerProductDataEntity
     */
    'description': string;
    /**
     * 
     * @type {Array<PaymentsManagerProductPriceEntity>}
     * @memberof PaymentsManagerProductDataEntity
     */
    'prices': Array<PaymentsManagerProductPriceEntity>;
}
/**
 * 
 * @export
 * @interface PaymentsManagerProductPriceEntity
 */
export interface PaymentsManagerProductPriceEntity {
    /**
     * 
     * @type {string}
     * @memberof PaymentsManagerProductPriceEntity
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentsManagerProductPriceEntity
     */
    'active': boolean;
    /**
     * 
     * @type {number}
     * @memberof PaymentsManagerProductPriceEntity
     */
    'unitAmount': number;
    /**
     * 
     * @type {string}
     * @memberof PaymentsManagerProductPriceEntity
     */
    'interval': string;
}
/**
 * 
 * @export
 * @interface PlainBankAccountEntity
 */
export interface PlainBankAccountEntity {
    /**
     * 
     * @type {string}
     * @memberof PlainBankAccountEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlainBankAccountEntity
     */
    'bankConnectionId': string;
    /**
     * 
     * @type {string}
     * @memberof PlainBankAccountEntity
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof PlainBankAccountEntity
     */
    'providerAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof PlainBankAccountEntity
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof PlainBankAccountEntity
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof PlainBankAccountEntity
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof PlainBankAccountEntity
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof PlainBankAccountEntity
     */
    'currencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof PlainBankAccountEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlainBankAccountEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PlainBankAccountEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PluggyConnectTokenEntity
 */
export interface PluggyConnectTokenEntity {
    /**
     * 
     * @type {string}
     * @memberof PluggyConnectTokenEntity
     */
    'accessToken': string;
}
/**
 * 
 * @export
 * @interface ProfileEntity
 */
export interface ProfileEntity {
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'birthDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface RefreshRequestDto
 */
export interface RefreshRequestDto {
    /**
     * 
     * @type {string}
     * @memberof RefreshRequestDto
     */
    'clientId': string;
}
/**
 * 
 * @export
 * @interface SendEmailVerificationCodeRequestDto
 */
export interface SendEmailVerificationCodeRequestDto {
    /**
     * 
     * @type {string}
     * @memberof SendEmailVerificationCodeRequestDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface SignInWithEmailPasswordRequestDto
 */
export interface SignInWithEmailPasswordRequestDto {
    /**
     * 
     * @type {string}
     * @memberof SignInWithEmailPasswordRequestDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignInWithEmailPasswordRequestDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignInWithEmailPasswordRequestDto
     */
    'clientId': string;
}
/**
 * 
 * @export
 * @interface SignUpWithEmailPasswordRequestDto
 */
export interface SignUpWithEmailPasswordRequestDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpWithEmailPasswordRequestDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpWithEmailPasswordRequestDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpWithEmailPasswordRequestDto
     */
    'emailVerificationCode': string;
}
/**
 * 
 * @export
 * @interface SubscriptionProductEntity
 */
export interface SubscriptionProductEntity {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionProductEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionProductEntity
     */
    'paymentSystem': string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionProductEntity
     */
    'paymentSystemProductId': string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionProductEntity
     */
    'workspaceType': string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionProductEntity
     */
    'trialPeriodInDays'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionProductEntity
     */
    'trialAlreadyUsed'?: boolean;
    /**
     * 
     * @type {ConnectionFeatureSpecificationEntity}
     * @memberof SubscriptionProductEntity
     */
    'connectionFeatureSpecification': ConnectionFeatureSpecificationEntity;
    /**
     * 
     * @type {FinancialTransactionsFeatureSpecificationEntity}
     * @memberof SubscriptionProductEntity
     */
    'financialTransactionsFeatureSpecification': FinancialTransactionsFeatureSpecificationEntity;
    /**
     * 
     * @type {AiChatFeatureSpecificationEntity}
     * @memberof SubscriptionProductEntity
     */
    'aiChatFeatureSpecification': AiChatFeatureSpecificationEntity;
    /**
     * 
     * @type {PaymentsManagerProductDataEntity}
     * @memberof SubscriptionProductEntity
     */
    'paymentsManagerData': PaymentsManagerProductDataEntity;
}
/**
 * 
 * @export
 * @interface UpdateBankTransactionRequestDto
 */
export interface UpdateBankTransactionRequestDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateBankTransactionRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBankTransactionRequestDto
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBankTransactionRequestDto
     */
    'costCenterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBankTransactionRequestDto
     */
    'competencyDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateBankTransactionRequestDto
     */
    'ignore'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateBankTransactionRequestDto
     */
    'confirm'?: boolean;
}
/**
 * 
 * @export
 * @interface UserEntity
 */
export interface UserEntity {
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'passwordHash'?: string;
}
/**
 * 
 * @export
 * @interface UserRelatedWorkspaceEntity
 */
export interface UserRelatedWorkspaceEntity {
    /**
     * 
     * @type {string}
     * @memberof UserRelatedWorkspaceEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserRelatedWorkspaceEntity
     */
    'prettyId': string;
    /**
     * 
     * @type {string}
     * @memberof UserRelatedWorkspaceEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserRelatedWorkspaceEntity
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof UserRelatedWorkspaceEntity
     */
    'creatorUserId': string;
    /**
     * 
     * @type {string}
     * @memberof UserRelatedWorkspaceEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserRelatedWorkspaceEntity
     */
    'relationType': string;
}
/**
 * 
 * @export
 * @interface WorkspaceEntity
 */
export interface WorkspaceEntity {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'prettyId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'creatorUserId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'selectedTreeId': string;
}
/**
 * 
 * @export
 * @interface WorkspaceJoinRequestEntity
 */
export interface WorkspaceJoinRequestEntity {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceJoinRequestEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceJoinRequestEntity
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceJoinRequestEntity
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceJoinRequestEntity
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceJoinRequestEntity
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface WorkspaceSubscriptionEntity
 */
export interface WorkspaceSubscriptionEntity {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSubscriptionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSubscriptionEntity
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSubscriptionEntity
     */
    'subscriptionProductId': string;
    /**
     * 
     * @type {SubscriptionProductEntity}
     * @memberof WorkspaceSubscriptionEntity
     */
    'subscriptionProduct': SubscriptionProductEntity;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSubscriptionEntity
     */
    'status': WorkspaceSubscriptionEntityStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSubscriptionEntity
     */
    'paymentSystem': WorkspaceSubscriptionEntityPaymentSystemEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSubscriptionEntity
     */
    'paymentSystemSubscriptionId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSubscriptionEntity
     */
    'createdAt': string;
}

export const WorkspaceSubscriptionEntityStatusEnum = {
    Active: 'ACTIVE',
    NotActive: 'NOT_ACTIVE',
    Trial: 'TRIAL'
} as const;

export type WorkspaceSubscriptionEntityStatusEnum = typeof WorkspaceSubscriptionEntityStatusEnum[keyof typeof WorkspaceSubscriptionEntityStatusEnum];
export const WorkspaceSubscriptionEntityPaymentSystemEnum = {
    Stripe: 'STRIPE'
} as const;

export type WorkspaceSubscriptionEntityPaymentSystemEnum = typeof WorkspaceSubscriptionEntityPaymentSystemEnum[keyof typeof WorkspaceSubscriptionEntityPaymentSystemEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CheckEmailInUseRequestDto} checkEmailInUseRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCheckEmailInUse: async (checkEmailInUseRequestDto: CheckEmailInUseRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkEmailInUseRequestDto' is not null or undefined
            assertParamExists('authControllerCheckEmailInUse', 'checkEmailInUseRequestDto', checkEmailInUseRequestDto)
            const localVarPath = `/auth/check-email-in-use`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkEmailInUseRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshRequestDto} refreshRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh: async (refreshRequestDto: RefreshRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshRequestDto' is not null or undefined
            assertParamExists('authControllerRefresh', 'refreshRequestDto', refreshRequestDto)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendEmailVerificationCodeRequestDto} sendEmailVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSendEmailVerificationCode: async (sendEmailVerificationCodeRequestDto: SendEmailVerificationCodeRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendEmailVerificationCodeRequestDto' is not null or undefined
            assertParamExists('authControllerSendEmailVerificationCode', 'sendEmailVerificationCodeRequestDto', sendEmailVerificationCodeRequestDto)
            const localVarPath = `/auth/sign-up/email-verification-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendEmailVerificationCodeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInWithEmailPasswordRequestDto} signInWithEmailPasswordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignInWithEmailPassword: async (signInWithEmailPasswordRequestDto: SignInWithEmailPasswordRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInWithEmailPasswordRequestDto' is not null or undefined
            assertParamExists('authControllerSignInWithEmailPassword', 'signInWithEmailPasswordRequestDto', signInWithEmailPasswordRequestDto)
            const localVarPath = `/auth/sign-in/email-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInWithEmailPasswordRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpWithEmailPasswordRequestDto} signUpWithEmailPasswordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUpWithEmailPassword: async (signUpWithEmailPasswordRequestDto: SignUpWithEmailPasswordRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpWithEmailPasswordRequestDto' is not null or undefined
            assertParamExists('authControllerSignUpWithEmailPassword', 'signUpWithEmailPasswordRequestDto', signUpWithEmailPasswordRequestDto)
            const localVarPath = `/auth/sign-up/email-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpWithEmailPasswordRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CheckEmailInUseRequestDto} checkEmailInUseRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerCheckEmailInUse(checkEmailInUseRequestDto: CheckEmailInUseRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailInUseEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerCheckEmailInUse(checkEmailInUseRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerCheckEmailInUse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshRequestDto} refreshRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefresh(refreshRequestDto: RefreshRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefresh(refreshRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SendEmailVerificationCodeRequestDto} sendEmailVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSendEmailVerificationCode(sendEmailVerificationCodeRequestDto: SendEmailVerificationCodeRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSendEmailVerificationCode(sendEmailVerificationCodeRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSendEmailVerificationCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignInWithEmailPasswordRequestDto} signInWithEmailPasswordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignInWithEmailPassword(signInWithEmailPasswordRequestDto: SignInWithEmailPasswordRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignInWithEmailPassword(signInWithEmailPasswordRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignInWithEmailPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignUpWithEmailPasswordRequestDto} signUpWithEmailPasswordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignUpWithEmailPassword(signUpWithEmailPasswordRequestDto: SignUpWithEmailPasswordRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignUpWithEmailPassword(signUpWithEmailPasswordRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignUpWithEmailPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {CheckEmailInUseRequestDto} checkEmailInUseRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerCheckEmailInUse(checkEmailInUseRequestDto: CheckEmailInUseRequestDto, options?: any): AxiosPromise<EmailInUseEntity> {
            return localVarFp.authControllerCheckEmailInUse(checkEmailInUseRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshRequestDto} refreshRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh(refreshRequestDto: RefreshRequestDto, options?: any): AxiosPromise<CredentialsEntity> {
            return localVarFp.authControllerRefresh(refreshRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendEmailVerificationCodeRequestDto} sendEmailVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSendEmailVerificationCode(sendEmailVerificationCodeRequestDto: SendEmailVerificationCodeRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSendEmailVerificationCode(sendEmailVerificationCodeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInWithEmailPasswordRequestDto} signInWithEmailPasswordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignInWithEmailPassword(signInWithEmailPasswordRequestDto: SignInWithEmailPasswordRequestDto, options?: any): AxiosPromise<CredentialsEntity> {
            return localVarFp.authControllerSignInWithEmailPassword(signInWithEmailPasswordRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpWithEmailPasswordRequestDto} signUpWithEmailPasswordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUpWithEmailPassword(signUpWithEmailPasswordRequestDto: SignUpWithEmailPasswordRequestDto, options?: any): AxiosPromise<UserEntity> {
            return localVarFp.authControllerSignUpWithEmailPassword(signUpWithEmailPasswordRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {CheckEmailInUseRequestDto} checkEmailInUseRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerCheckEmailInUse(checkEmailInUseRequestDto: CheckEmailInUseRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerCheckEmailInUse(checkEmailInUseRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshRequestDto} refreshRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefresh(refreshRequestDto: RefreshRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefresh(refreshRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendEmailVerificationCodeRequestDto} sendEmailVerificationCodeRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSendEmailVerificationCode(sendEmailVerificationCodeRequestDto: SendEmailVerificationCodeRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSendEmailVerificationCode(sendEmailVerificationCodeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInWithEmailPasswordRequestDto} signInWithEmailPasswordRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignInWithEmailPassword(signInWithEmailPasswordRequestDto: SignInWithEmailPasswordRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignInWithEmailPassword(signInWithEmailPasswordRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpWithEmailPasswordRequestDto} signUpWithEmailPasswordRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignUpWithEmailPassword(signUpWithEmailPasswordRequestDto: SignUpWithEmailPasswordRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignUpWithEmailPassword(signUpWithEmailPasswordRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankAccountsApi - axios parameter creator
 * @export
 */
export const BankAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerActivateBankAccount: async (bankAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankAccountId' is not null or undefined
            assertParamExists('bankAccountsControllerActivateBankAccount', 'bankAccountId', bankAccountId)
            const localVarPath = `/bank/accounts/{bankAccountId}/activate`
                .replace(`{${"bankAccountId"}}`, encodeURIComponent(String(bankAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateBankAccountRequestDto} createOrUpdateBankAccountRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerCreateOrUpdateBankAccount: async (workspaceId: string, createOrUpdateBankAccountRequestDto: CreateOrUpdateBankAccountRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankAccountsControllerCreateOrUpdateBankAccount', 'workspaceId', workspaceId)
            // verify required parameter 'createOrUpdateBankAccountRequestDto' is not null or undefined
            assertParamExists('bankAccountsControllerCreateOrUpdateBankAccount', 'createOrUpdateBankAccountRequestDto', createOrUpdateBankAccountRequestDto)
            const localVarPath = `/workspaces/{workspaceId}/bank/accounts`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateBankAccountRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerCreateWorkspaceBankAccountsBalanceReport: async (workspaceId: string, enabled?: boolean, types?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankAccountsControllerCreateWorkspaceBankAccountsBalanceReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/bank/accounts/balance-report`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerDisableBankAccount: async (bankAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankAccountId' is not null or undefined
            assertParamExists('bankAccountsControllerDisableBankAccount', 'bankAccountId', bankAccountId)
            const localVarPath = `/bank/accounts/{bankAccountId}/disable`
                .replace(`{${"bankAccountId"}}`, encodeURIComponent(String(bankAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} bankConnectionId 
         * @param {boolean} enabled 
         * @param {string} types 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerFetchConnectionBankAccounts: async (workspaceId: string, bankConnectionId: string, enabled: boolean, types: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankAccountsControllerFetchConnectionBankAccounts', 'workspaceId', workspaceId)
            // verify required parameter 'bankConnectionId' is not null or undefined
            assertParamExists('bankAccountsControllerFetchConnectionBankAccounts', 'bankConnectionId', bankConnectionId)
            // verify required parameter 'enabled' is not null or undefined
            assertParamExists('bankAccountsControllerFetchConnectionBankAccounts', 'enabled', enabled)
            // verify required parameter 'types' is not null or undefined
            assertParamExists('bankAccountsControllerFetchConnectionBankAccounts', 'types', types)
            const localVarPath = `/workspaces/{workspaceId}/bank/connections/{bankConnectionId}/accounts`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"bankConnectionId"}}`, encodeURIComponent(String(bankConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerFetchWorkspaceBankAccounts: async (workspaceId: string, enabled?: boolean, types?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankAccountsControllerFetchWorkspaceBankAccounts', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/bank/accounts`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerGetBankAccountDetails: async (bankAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankAccountId' is not null or undefined
            assertParamExists('bankAccountsControllerGetBankAccountDetails', 'bankAccountId', bankAccountId)
            const localVarPath = `/bank/accounts/{bankAccountId}`
                .replace(`{${"bankAccountId"}}`, encodeURIComponent(String(bankAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankAccountsApi - functional programming interface
 * @export
 */
export const BankAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerActivateBankAccount(bankAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerActivateBankAccount(bankAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerActivateBankAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateBankAccountRequestDto} createOrUpdateBankAccountRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerCreateOrUpdateBankAccount(workspaceId: string, createOrUpdateBankAccountRequestDto: CreateOrUpdateBankAccountRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerCreateOrUpdateBankAccount(workspaceId, createOrUpdateBankAccountRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerCreateOrUpdateBankAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerCreateWorkspaceBankAccountsBalanceReport(workspaceId: string, enabled?: boolean, types?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountsBalanceReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerCreateWorkspaceBankAccountsBalanceReport(workspaceId, enabled, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerCreateWorkspaceBankAccountsBalanceReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerDisableBankAccount(bankAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerDisableBankAccount(bankAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerDisableBankAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} bankConnectionId 
         * @param {boolean} enabled 
         * @param {string} types 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerFetchConnectionBankAccounts(workspaceId: string, bankConnectionId: string, enabled: boolean, types: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankAccountEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerFetchConnectionBankAccounts(workspaceId, bankConnectionId, enabled, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerFetchConnectionBankAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerFetchWorkspaceBankAccounts(workspaceId: string, enabled?: boolean, types?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankAccountEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerFetchWorkspaceBankAccounts(workspaceId, enabled, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerFetchWorkspaceBankAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerGetBankAccountDetails(bankAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerGetBankAccountDetails(bankAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerGetBankAccountDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankAccountsApi - factory interface
 * @export
 */
export const BankAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankAccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerActivateBankAccount(bankAccountId: string, options?: any): AxiosPromise<BankAccountEntity> {
            return localVarFp.bankAccountsControllerActivateBankAccount(bankAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateBankAccountRequestDto} createOrUpdateBankAccountRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerCreateOrUpdateBankAccount(workspaceId: string, createOrUpdateBankAccountRequestDto: CreateOrUpdateBankAccountRequestDto, options?: any): AxiosPromise<BankAccountEntity> {
            return localVarFp.bankAccountsControllerCreateOrUpdateBankAccount(workspaceId, createOrUpdateBankAccountRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerCreateWorkspaceBankAccountsBalanceReport(workspaceId: string, enabled?: boolean, types?: string, options?: any): AxiosPromise<BankAccountsBalanceReportEntity> {
            return localVarFp.bankAccountsControllerCreateWorkspaceBankAccountsBalanceReport(workspaceId, enabled, types, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerDisableBankAccount(bankAccountId: string, options?: any): AxiosPromise<BankAccountEntity> {
            return localVarFp.bankAccountsControllerDisableBankAccount(bankAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} bankConnectionId 
         * @param {boolean} enabled 
         * @param {string} types 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerFetchConnectionBankAccounts(workspaceId: string, bankConnectionId: string, enabled: boolean, types: string, options?: any): AxiosPromise<Array<BankAccountEntity>> {
            return localVarFp.bankAccountsControllerFetchConnectionBankAccounts(workspaceId, bankConnectionId, enabled, types, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerFetchWorkspaceBankAccounts(workspaceId: string, enabled?: boolean, types?: string, options?: any): AxiosPromise<Array<BankAccountEntity>> {
            return localVarFp.bankAccountsControllerFetchWorkspaceBankAccounts(workspaceId, enabled, types, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerGetBankAccountDetails(bankAccountId: string, options?: any): AxiosPromise<BankAccountEntity> {
            return localVarFp.bankAccountsControllerGetBankAccountDetails(bankAccountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankAccountsApi - object-oriented interface
 * @export
 * @class BankAccountsApi
 * @extends {BaseAPI}
 */
export class BankAccountsApi extends BaseAPI {
    /**
     * 
     * @param {string} bankAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerActivateBankAccount(bankAccountId: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerActivateBankAccount(bankAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {CreateOrUpdateBankAccountRequestDto} createOrUpdateBankAccountRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerCreateOrUpdateBankAccount(workspaceId: string, createOrUpdateBankAccountRequestDto: CreateOrUpdateBankAccountRequestDto, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerCreateOrUpdateBankAccount(workspaceId, createOrUpdateBankAccountRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {boolean} [enabled] 
     * @param {string} [types] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerCreateWorkspaceBankAccountsBalanceReport(workspaceId: string, enabled?: boolean, types?: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerCreateWorkspaceBankAccountsBalanceReport(workspaceId, enabled, types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerDisableBankAccount(bankAccountId: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerDisableBankAccount(bankAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} bankConnectionId 
     * @param {boolean} enabled 
     * @param {string} types 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerFetchConnectionBankAccounts(workspaceId: string, bankConnectionId: string, enabled: boolean, types: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerFetchConnectionBankAccounts(workspaceId, bankConnectionId, enabled, types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {boolean} [enabled] 
     * @param {string} [types] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerFetchWorkspaceBankAccounts(workspaceId: string, enabled?: boolean, types?: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerFetchWorkspaceBankAccounts(workspaceId, enabled, types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerGetBankAccountDetails(bankAccountId: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerGetBankAccountDetails(bankAccountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankConnectionsApi - axios parameter creator
 * @export
 */
export const BankConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerActivateBankConnection: async (bankConnectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankConnectionId' is not null or undefined
            assertParamExists('bankConnectionsControllerActivateBankConnection', 'bankConnectionId', bankConnectionId)
            const localVarPath = `/bank/connections/{bankConnectionId}/activate`
                .replace(`{${"bankConnectionId"}}`, encodeURIComponent(String(bankConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateBankConnectionRequestDto} createOrUpdateBankConnectionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerCreateOrUpdateBankConnection: async (workspaceId: string, createOrUpdateBankConnectionRequestDto: CreateOrUpdateBankConnectionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankConnectionsControllerCreateOrUpdateBankConnection', 'workspaceId', workspaceId)
            // verify required parameter 'createOrUpdateBankConnectionRequestDto' is not null or undefined
            assertParamExists('bankConnectionsControllerCreateOrUpdateBankConnection', 'createOrUpdateBankConnectionRequestDto', createOrUpdateBankConnectionRequestDto)
            const localVarPath = `/workspaces/{workspaceId}/bank/connections`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateBankConnectionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerDisableBankConnection: async (bankConnectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankConnectionId' is not null or undefined
            assertParamExists('bankConnectionsControllerDisableBankConnection', 'bankConnectionId', bankConnectionId)
            const localVarPath = `/bank/connections/{bankConnectionId}/disable`
                .replace(`{${"bankConnectionId"}}`, encodeURIComponent(String(bankConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerFetchUserBankConnections: async (workspaceId: string, enabled?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankConnectionsControllerFetchUserBankConnections', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/bank/connections`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerGetBankConnectionDetails: async (bankConnectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankConnectionId' is not null or undefined
            assertParamExists('bankConnectionsControllerGetBankConnectionDetails', 'bankConnectionId', bankConnectionId)
            const localVarPath = `/bank/connections/{bankConnectionId}`
                .replace(`{${"bankConnectionId"}}`, encodeURIComponent(String(bankConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankConnectionsApi - functional programming interface
 * @export
 */
export const BankConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankConnectionsControllerActivateBankConnection(bankConnectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankConnectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankConnectionsControllerActivateBankConnection(bankConnectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankConnectionsApi.bankConnectionsControllerActivateBankConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateBankConnectionRequestDto} createOrUpdateBankConnectionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankConnectionsControllerCreateOrUpdateBankConnection(workspaceId: string, createOrUpdateBankConnectionRequestDto: CreateOrUpdateBankConnectionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankConnectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankConnectionsControllerCreateOrUpdateBankConnection(workspaceId, createOrUpdateBankConnectionRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankConnectionsApi.bankConnectionsControllerCreateOrUpdateBankConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankConnectionsControllerDisableBankConnection(bankConnectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankConnectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankConnectionsControllerDisableBankConnection(bankConnectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankConnectionsApi.bankConnectionsControllerDisableBankConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankConnectionsControllerFetchUserBankConnections(workspaceId: string, enabled?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankConnectionWithAccountsEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankConnectionsControllerFetchUserBankConnections(workspaceId, enabled, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankConnectionsApi.bankConnectionsControllerFetchUserBankConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankConnectionsControllerGetBankConnectionDetails(bankConnectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankConnectionWithAccountsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankConnectionsControllerGetBankConnectionDetails(bankConnectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankConnectionsApi.bankConnectionsControllerGetBankConnectionDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankConnectionsApi - factory interface
 * @export
 */
export const BankConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerActivateBankConnection(bankConnectionId: string, options?: any): AxiosPromise<BankConnectionEntity> {
            return localVarFp.bankConnectionsControllerActivateBankConnection(bankConnectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateBankConnectionRequestDto} createOrUpdateBankConnectionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerCreateOrUpdateBankConnection(workspaceId: string, createOrUpdateBankConnectionRequestDto: CreateOrUpdateBankConnectionRequestDto, options?: any): AxiosPromise<BankConnectionEntity> {
            return localVarFp.bankConnectionsControllerCreateOrUpdateBankConnection(workspaceId, createOrUpdateBankConnectionRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerDisableBankConnection(bankConnectionId: string, options?: any): AxiosPromise<BankConnectionEntity> {
            return localVarFp.bankConnectionsControllerDisableBankConnection(bankConnectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerFetchUserBankConnections(workspaceId: string, enabled?: boolean, options?: any): AxiosPromise<Array<BankConnectionWithAccountsEntity>> {
            return localVarFp.bankConnectionsControllerFetchUserBankConnections(workspaceId, enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerGetBankConnectionDetails(bankConnectionId: string, options?: any): AxiosPromise<BankConnectionWithAccountsEntity> {
            return localVarFp.bankConnectionsControllerGetBankConnectionDetails(bankConnectionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankConnectionsApi - object-oriented interface
 * @export
 * @class BankConnectionsApi
 * @extends {BaseAPI}
 */
export class BankConnectionsApi extends BaseAPI {
    /**
     * 
     * @param {string} bankConnectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankConnectionsApi
     */
    public bankConnectionsControllerActivateBankConnection(bankConnectionId: string, options?: RawAxiosRequestConfig) {
        return BankConnectionsApiFp(this.configuration).bankConnectionsControllerActivateBankConnection(bankConnectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {CreateOrUpdateBankConnectionRequestDto} createOrUpdateBankConnectionRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankConnectionsApi
     */
    public bankConnectionsControllerCreateOrUpdateBankConnection(workspaceId: string, createOrUpdateBankConnectionRequestDto: CreateOrUpdateBankConnectionRequestDto, options?: RawAxiosRequestConfig) {
        return BankConnectionsApiFp(this.configuration).bankConnectionsControllerCreateOrUpdateBankConnection(workspaceId, createOrUpdateBankConnectionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankConnectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankConnectionsApi
     */
    public bankConnectionsControllerDisableBankConnection(bankConnectionId: string, options?: RawAxiosRequestConfig) {
        return BankConnectionsApiFp(this.configuration).bankConnectionsControllerDisableBankConnection(bankConnectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {boolean} [enabled] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankConnectionsApi
     */
    public bankConnectionsControllerFetchUserBankConnections(workspaceId: string, enabled?: boolean, options?: RawAxiosRequestConfig) {
        return BankConnectionsApiFp(this.configuration).bankConnectionsControllerFetchUserBankConnections(workspaceId, enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankConnectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankConnectionsApi
     */
    public bankConnectionsControllerGetBankConnectionDetails(bankConnectionId: string, options?: RawAxiosRequestConfig) {
        return BankConnectionsApiFp(this.configuration).bankConnectionsControllerGetBankConnectionDetails(bankConnectionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankTransactionCategoriesApi - axios parameter creator
 * @export
 */
export const BankTransactionCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [onlyLeafs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionCategoriesControllerGetBankTransactionCategories: async (workspaceId: string, onlyLeafs?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionCategoriesControllerGetBankTransactionCategories', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/bank/transactions/categories`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (onlyLeafs !== undefined) {
                localVarQueryParameter['onlyLeafs'] = onlyLeafs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankTransactionCategoriesApi - functional programming interface
 * @export
 */
export const BankTransactionCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankTransactionCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [onlyLeafs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionCategoriesControllerGetBankTransactionCategories(workspaceId: string, onlyLeafs?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankTransactionCategoryEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionCategoriesControllerGetBankTransactionCategories(workspaceId, onlyLeafs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionCategoriesApi.bankTransactionCategoriesControllerGetBankTransactionCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankTransactionCategoriesApi - factory interface
 * @export
 */
export const BankTransactionCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankTransactionCategoriesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [onlyLeafs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionCategoriesControllerGetBankTransactionCategories(workspaceId: string, onlyLeafs?: boolean, options?: any): AxiosPromise<Array<BankTransactionCategoryEntity>> {
            return localVarFp.bankTransactionCategoriesControllerGetBankTransactionCategories(workspaceId, onlyLeafs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankTransactionCategoriesApi - object-oriented interface
 * @export
 * @class BankTransactionCategoriesApi
 * @extends {BaseAPI}
 */
export class BankTransactionCategoriesApi extends BaseAPI {
    /**
     * 
     * @param {string} workspaceId 
     * @param {boolean} [onlyLeafs] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionCategoriesApi
     */
    public bankTransactionCategoriesControllerGetBankTransactionCategories(workspaceId: string, onlyLeafs?: boolean, options?: RawAxiosRequestConfig) {
        return BankTransactionCategoriesApiFp(this.configuration).bankTransactionCategoriesControllerGetBankTransactionCategories(workspaceId, onlyLeafs, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankTransactionCostCentersApi - axios parameter creator
 * @export
 */
export const BankTransactionCostCentersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateBankTransactionCostCenterRequestDto} createBankTransactionCostCenterRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionCostCentersControllerCreateCostCenter: async (workspaceId: string, createBankTransactionCostCenterRequestDto: CreateBankTransactionCostCenterRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionCostCentersControllerCreateCostCenter', 'workspaceId', workspaceId)
            // verify required parameter 'createBankTransactionCostCenterRequestDto' is not null or undefined
            assertParamExists('bankTransactionCostCentersControllerCreateCostCenter', 'createBankTransactionCostCenterRequestDto', createBankTransactionCostCenterRequestDto)
            const localVarPath = `/workspaces/{workspaceId}/bank/transactions/cost-centers`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBankTransactionCostCenterRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionCostCentersControllerListCostCenters: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionCostCentersControllerListCostCenters', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/bank/transactions/cost-centers`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankTransactionCostCentersApi - functional programming interface
 * @export
 */
export const BankTransactionCostCentersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankTransactionCostCentersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateBankTransactionCostCenterRequestDto} createBankTransactionCostCenterRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionCostCentersControllerCreateCostCenter(workspaceId: string, createBankTransactionCostCenterRequestDto: CreateBankTransactionCostCenterRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionCostCenterEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionCostCentersControllerCreateCostCenter(workspaceId, createBankTransactionCostCenterRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionCostCentersApi.bankTransactionCostCentersControllerCreateCostCenter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionCostCentersControllerListCostCenters(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankTransactionCostCenterEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionCostCentersControllerListCostCenters(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionCostCentersApi.bankTransactionCostCentersControllerListCostCenters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankTransactionCostCentersApi - factory interface
 * @export
 */
export const BankTransactionCostCentersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankTransactionCostCentersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateBankTransactionCostCenterRequestDto} createBankTransactionCostCenterRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionCostCentersControllerCreateCostCenter(workspaceId: string, createBankTransactionCostCenterRequestDto: CreateBankTransactionCostCenterRequestDto, options?: any): AxiosPromise<BankTransactionCostCenterEntity> {
            return localVarFp.bankTransactionCostCentersControllerCreateCostCenter(workspaceId, createBankTransactionCostCenterRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionCostCentersControllerListCostCenters(workspaceId: string, options?: any): AxiosPromise<Array<BankTransactionCostCenterEntity>> {
            return localVarFp.bankTransactionCostCentersControllerListCostCenters(workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankTransactionCostCentersApi - object-oriented interface
 * @export
 * @class BankTransactionCostCentersApi
 * @extends {BaseAPI}
 */
export class BankTransactionCostCentersApi extends BaseAPI {
    /**
     * 
     * @param {string} workspaceId 
     * @param {CreateBankTransactionCostCenterRequestDto} createBankTransactionCostCenterRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionCostCentersApi
     */
    public bankTransactionCostCentersControllerCreateCostCenter(workspaceId: string, createBankTransactionCostCenterRequestDto: CreateBankTransactionCostCenterRequestDto, options?: RawAxiosRequestConfig) {
        return BankTransactionCostCentersApiFp(this.configuration).bankTransactionCostCentersControllerCreateCostCenter(workspaceId, createBankTransactionCostCenterRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionCostCentersApi
     */
    public bankTransactionCostCentersControllerListCostCenters(workspaceId: string, options?: RawAxiosRequestConfig) {
        return BankTransactionCostCentersApiFp(this.configuration).bankTransactionCostCentersControllerListCostCenters(workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankTransactionsApi - axios parameter creator
 * @export
 */
export const BankTransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateOrUpdateBankTransactionsInBulkRequestDto} createOrUpdateBankTransactionsInBulkRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerCreateOrUpdateBankTransactionsInBulk: async (createOrUpdateBankTransactionsInBulkRequestDto: CreateOrUpdateBankTransactionsInBulkRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrUpdateBankTransactionsInBulkRequestDto' is not null or undefined
            assertParamExists('bankTransactionsControllerCreateOrUpdateBankTransactionsInBulk', 'createOrUpdateBankTransactionsInBulkRequestDto', createOrUpdateBankTransactionsInBulkRequestDto)
            const localVarPath = `/bank/transactions/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateBankTransactionsInBulkRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [costCenterIds] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {boolean} [showIgnored] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetBankTransactions: async (workspaceId: string, pageIndex?: number, pageSize?: number, accountIds?: string, categoryIds?: string, costCenterIds?: string, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, showIgnored?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionsControllerGetBankTransactions', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/bank/transactions`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (categoryIds !== undefined) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (costCenterIds !== undefined) {
                localVarQueryParameter['costCenterIds'] = costCenterIds;
            }

            if (minPostedDate !== undefined) {
                localVarQueryParameter['minPostedDate'] = minPostedDate;
            }

            if (maxPostedDate !== undefined) {
                localVarQueryParameter['maxPostedDate'] = maxPostedDate;
            }

            if (minCompetencyDate !== undefined) {
                localVarQueryParameter['minCompetencyDate'] = minCompetencyDate;
            }

            if (maxCompetencyDate !== undefined) {
                localVarQueryParameter['maxCompetencyDate'] = maxCompetencyDate;
            }

            if (showIgnored !== undefined) {
                localVarQueryParameter['showIgnored'] = showIgnored;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetBankTransactionsConfirmedTodayByMe: async (workspaceId: string, pageIndex?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionsControllerGetBankTransactionsConfirmedTodayByMe', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/bank/transactions/confirmed-today-by-me`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {boolean} [considerIgnored] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetBankTransactionsNotConfirmed: async (workspaceId: string, pageIndex?: number, pageSize?: number, considerIgnored?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionsControllerGetBankTransactionsNotConfirmed', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/bank/transactions/not-confirmed`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetRecent: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionsControllerGetRecent', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/bank/transactions/most-recent`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetTransactionDetails: async (bankTransactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankTransactionId' is not null or undefined
            assertParamExists('bankTransactionsControllerGetTransactionDetails', 'bankTransactionId', bankTransactionId)
            const localVarPath = `/bank/transactions/{bankTransactionId}`
                .replace(`{${"bankTransactionId"}}`, encodeURIComponent(String(bankTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {UpdateBankTransactionRequestDto} updateBankTransactionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerUpdateTransaction: async (bankTransactionId: string, updateBankTransactionRequestDto: UpdateBankTransactionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankTransactionId' is not null or undefined
            assertParamExists('bankTransactionsControllerUpdateTransaction', 'bankTransactionId', bankTransactionId)
            // verify required parameter 'updateBankTransactionRequestDto' is not null or undefined
            assertParamExists('bankTransactionsControllerUpdateTransaction', 'updateBankTransactionRequestDto', updateBankTransactionRequestDto)
            const localVarPath = `/bank/transactions/{bankTransactionId}`
                .replace(`{${"bankTransactionId"}}`, encodeURIComponent(String(bankTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBankTransactionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankTransactionsApi - functional programming interface
 * @export
 */
export const BankTransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankTransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateOrUpdateBankTransactionsInBulkRequestDto} createOrUpdateBankTransactionsInBulkRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerCreateOrUpdateBankTransactionsInBulk(createOrUpdateBankTransactionsInBulkRequestDto: CreateOrUpdateBankTransactionsInBulkRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankTransactionEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerCreateOrUpdateBankTransactionsInBulk(createOrUpdateBankTransactionsInBulkRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerCreateOrUpdateBankTransactionsInBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [costCenterIds] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {boolean} [showIgnored] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerGetBankTransactions(workspaceId: string, pageIndex?: number, pageSize?: number, accountIds?: string, categoryIds?: string, costCenterIds?: string, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, showIgnored?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionsPageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerGetBankTransactions(workspaceId, pageIndex, pageSize, accountIds, categoryIds, costCenterIds, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, showIgnored, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerGetBankTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerGetBankTransactionsConfirmedTodayByMe(workspaceId: string, pageIndex?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionsPageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerGetBankTransactionsConfirmedTodayByMe(workspaceId, pageIndex, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerGetBankTransactionsConfirmedTodayByMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {boolean} [considerIgnored] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerGetBankTransactionsNotConfirmed(workspaceId: string, pageIndex?: number, pageSize?: number, considerIgnored?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionsPageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerGetBankTransactionsNotConfirmed(workspaceId, pageIndex, pageSize, considerIgnored, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerGetBankTransactionsNotConfirmed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerGetRecent(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankTransactionEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerGetRecent(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerGetRecent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerGetTransactionDetails(bankTransactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerGetTransactionDetails(bankTransactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerGetTransactionDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {UpdateBankTransactionRequestDto} updateBankTransactionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerUpdateTransaction(bankTransactionId: string, updateBankTransactionRequestDto: UpdateBankTransactionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerUpdateTransaction(bankTransactionId, updateBankTransactionRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerUpdateTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankTransactionsApi - factory interface
 * @export
 */
export const BankTransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankTransactionsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateOrUpdateBankTransactionsInBulkRequestDto} createOrUpdateBankTransactionsInBulkRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerCreateOrUpdateBankTransactionsInBulk(createOrUpdateBankTransactionsInBulkRequestDto: CreateOrUpdateBankTransactionsInBulkRequestDto, options?: any): AxiosPromise<Array<BankTransactionEntity>> {
            return localVarFp.bankTransactionsControllerCreateOrUpdateBankTransactionsInBulk(createOrUpdateBankTransactionsInBulkRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [costCenterIds] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {boolean} [showIgnored] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetBankTransactions(workspaceId: string, pageIndex?: number, pageSize?: number, accountIds?: string, categoryIds?: string, costCenterIds?: string, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, showIgnored?: boolean, options?: any): AxiosPromise<BankTransactionsPageEntity> {
            return localVarFp.bankTransactionsControllerGetBankTransactions(workspaceId, pageIndex, pageSize, accountIds, categoryIds, costCenterIds, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, showIgnored, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetBankTransactionsConfirmedTodayByMe(workspaceId: string, pageIndex?: number, pageSize?: number, options?: any): AxiosPromise<BankTransactionsPageEntity> {
            return localVarFp.bankTransactionsControllerGetBankTransactionsConfirmedTodayByMe(workspaceId, pageIndex, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {boolean} [considerIgnored] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetBankTransactionsNotConfirmed(workspaceId: string, pageIndex?: number, pageSize?: number, considerIgnored?: boolean, options?: any): AxiosPromise<BankTransactionsPageEntity> {
            return localVarFp.bankTransactionsControllerGetBankTransactionsNotConfirmed(workspaceId, pageIndex, pageSize, considerIgnored, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetRecent(workspaceId: string, options?: any): AxiosPromise<Array<BankTransactionEntity>> {
            return localVarFp.bankTransactionsControllerGetRecent(workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetTransactionDetails(bankTransactionId: string, options?: any): AxiosPromise<BankTransactionEntity> {
            return localVarFp.bankTransactionsControllerGetTransactionDetails(bankTransactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {UpdateBankTransactionRequestDto} updateBankTransactionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerUpdateTransaction(bankTransactionId: string, updateBankTransactionRequestDto: UpdateBankTransactionRequestDto, options?: any): AxiosPromise<BankTransactionEntity> {
            return localVarFp.bankTransactionsControllerUpdateTransaction(bankTransactionId, updateBankTransactionRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankTransactionsApi - object-oriented interface
 * @export
 * @class BankTransactionsApi
 * @extends {BaseAPI}
 */
export class BankTransactionsApi extends BaseAPI {
    /**
     * 
     * @param {CreateOrUpdateBankTransactionsInBulkRequestDto} createOrUpdateBankTransactionsInBulkRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerCreateOrUpdateBankTransactionsInBulk(createOrUpdateBankTransactionsInBulkRequestDto: CreateOrUpdateBankTransactionsInBulkRequestDto, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerCreateOrUpdateBankTransactionsInBulk(createOrUpdateBankTransactionsInBulkRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {string} [accountIds] 
     * @param {string} [categoryIds] 
     * @param {string} [costCenterIds] 
     * @param {string} [minPostedDate] 
     * @param {string} [maxPostedDate] 
     * @param {string} [minCompetencyDate] 
     * @param {string} [maxCompetencyDate] 
     * @param {boolean} [showIgnored] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerGetBankTransactions(workspaceId: string, pageIndex?: number, pageSize?: number, accountIds?: string, categoryIds?: string, costCenterIds?: string, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, showIgnored?: boolean, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerGetBankTransactions(workspaceId, pageIndex, pageSize, accountIds, categoryIds, costCenterIds, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, showIgnored, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerGetBankTransactionsConfirmedTodayByMe(workspaceId: string, pageIndex?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerGetBankTransactionsConfirmedTodayByMe(workspaceId, pageIndex, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {boolean} [considerIgnored] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerGetBankTransactionsNotConfirmed(workspaceId: string, pageIndex?: number, pageSize?: number, considerIgnored?: boolean, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerGetBankTransactionsNotConfirmed(workspaceId, pageIndex, pageSize, considerIgnored, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerGetRecent(workspaceId: string, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerGetRecent(workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankTransactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerGetTransactionDetails(bankTransactionId: string, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerGetTransactionDetails(bankTransactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankTransactionId 
     * @param {UpdateBankTransactionRequestDto} updateBankTransactionRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerUpdateTransaction(bankTransactionId: string, updateBankTransactionRequestDto: UpdateBankTransactionRequestDto, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerUpdateTransaction(bankTransactionId, updateBankTransactionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PluggyApi - axios parameter creator
 * @export
 */
export const PluggyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePluggyConnectTokenRequestDto} createPluggyConnectTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluggyControllerCreate: async (createPluggyConnectTokenRequestDto: CreatePluggyConnectTokenRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPluggyConnectTokenRequestDto' is not null or undefined
            assertParamExists('pluggyControllerCreate', 'createPluggyConnectTokenRequestDto', createPluggyConnectTokenRequestDto)
            const localVarPath = `/pluggy/connect-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPluggyConnectTokenRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluggyControllerWebhook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pluggy/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluggyApi - functional programming interface
 * @export
 */
export const PluggyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PluggyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePluggyConnectTokenRequestDto} createPluggyConnectTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluggyControllerCreate(createPluggyConnectTokenRequestDto: CreatePluggyConnectTokenRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluggyConnectTokenEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluggyControllerCreate(createPluggyConnectTokenRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluggyApi.pluggyControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluggyControllerWebhook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluggyControllerWebhook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluggyApi.pluggyControllerWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PluggyApi - factory interface
 * @export
 */
export const PluggyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PluggyApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePluggyConnectTokenRequestDto} createPluggyConnectTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluggyControllerCreate(createPluggyConnectTokenRequestDto: CreatePluggyConnectTokenRequestDto, options?: any): AxiosPromise<PluggyConnectTokenEntity> {
            return localVarFp.pluggyControllerCreate(createPluggyConnectTokenRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluggyControllerWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.pluggyControllerWebhook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluggyApi - object-oriented interface
 * @export
 * @class PluggyApi
 * @extends {BaseAPI}
 */
export class PluggyApi extends BaseAPI {
    /**
     * 
     * @param {CreatePluggyConnectTokenRequestDto} createPluggyConnectTokenRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluggyApi
     */
    public pluggyControllerCreate(createPluggyConnectTokenRequestDto: CreatePluggyConnectTokenRequestDto, options?: RawAxiosRequestConfig) {
        return PluggyApiFp(this.configuration).pluggyControllerCreate(createPluggyConnectTokenRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluggyApi
     */
    public pluggyControllerWebhook(options?: RawAxiosRequestConfig) {
        return PluggyApiFp(this.configuration).pluggyControllerWebhook(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProfileRequestDto} createProfileRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerCreate: async (createProfileRequestDto: CreateProfileRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProfileRequestDto' is not null or undefined
            assertParamExists('profilesControllerCreate', 'createProfileRequestDto', createProfileRequestDto)
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProfileRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerGetMy: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profiles/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProfileRequestDto} createProfileRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesControllerCreate(createProfileRequestDto: CreateProfileRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesControllerCreate(createProfileRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.profilesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesControllerGetMy(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesControllerGetMy(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.profilesControllerGetMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProfileRequestDto} createProfileRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerCreate(createProfileRequestDto: CreateProfileRequestDto, options?: any): AxiosPromise<ProfileEntity> {
            return localVarFp.profilesControllerCreate(createProfileRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerGetMy(options?: any): AxiosPromise<ProfileEntity> {
            return localVarFp.profilesControllerGetMy(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
    /**
     * 
     * @param {CreateProfileRequestDto} createProfileRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesControllerCreate(createProfileRequestDto: CreateProfileRequestDto, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesControllerCreate(createProfileRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesControllerGetMy(options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesControllerGetMy(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetAccountsEntriesByCategoryReport: async (workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetAccountsEntriesByCategoryReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/accounts/entries-by-category`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (costCenterIds !== undefined) {
                localVarQueryParameter['costCenterIds'] = costCenterIds;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (ignoreInternalTransfers !== undefined) {
                localVarQueryParameter['ignoreInternalTransfers'] = ignoreInternalTransfers;
            }

            if (minPostedDate !== undefined) {
                localVarQueryParameter['minPostedDate'] = minPostedDate;
            }

            if (maxPostedDate !== undefined) {
                localVarQueryParameter['maxPostedDate'] = maxPostedDate;
            }

            if (minCompetencyDate !== undefined) {
                localVarQueryParameter['minCompetencyDate'] = minCompetencyDate;
            }

            if (maxCompetencyDate !== undefined) {
                localVarQueryParameter['maxCompetencyDate'] = maxCompetencyDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetAccountsOutputsByCategoryReport: async (workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetAccountsOutputsByCategoryReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/accounts/outputs-by-category`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (costCenterIds !== undefined) {
                localVarQueryParameter['costCenterIds'] = costCenterIds;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (ignoreInternalTransfers !== undefined) {
                localVarQueryParameter['ignoreInternalTransfers'] = ignoreInternalTransfers;
            }

            if (minPostedDate !== undefined) {
                localVarQueryParameter['minPostedDate'] = minPostedDate;
            }

            if (maxPostedDate !== undefined) {
                localVarQueryParameter['maxPostedDate'] = maxPostedDate;
            }

            if (minCompetencyDate !== undefined) {
                localVarQueryParameter['minCompetencyDate'] = minCompetencyDate;
            }

            if (maxCompetencyDate !== undefined) {
                localVarQueryParameter['maxCompetencyDate'] = maxCompetencyDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCardsCashFlowReport: async (workspaceId: string, accountIds?: string, categoryIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInvoiceRelated?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetCardsCashFlowReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/cards/cash-flow`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (categoryIds !== undefined) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (costCenterIds !== undefined) {
                localVarQueryParameter['costCenterIds'] = costCenterIds;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (ignoreInvoiceRelated !== undefined) {
                localVarQueryParameter['ignoreInvoiceRelated'] = ignoreInvoiceRelated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCardsOutputsByCategoryReport: async (workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, ignoreInvoiceRelated?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetCardsOutputsByCategoryReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/cards/outputs-by-category`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (costCenterIds !== undefined) {
                localVarQueryParameter['costCenterIds'] = costCenterIds;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (minPostedDate !== undefined) {
                localVarQueryParameter['minPostedDate'] = minPostedDate;
            }

            if (maxPostedDate !== undefined) {
                localVarQueryParameter['maxPostedDate'] = maxPostedDate;
            }

            if (minCompetencyDate !== undefined) {
                localVarQueryParameter['minCompetencyDate'] = minCompetencyDate;
            }

            if (maxCompetencyDate !== undefined) {
                localVarQueryParameter['maxCompetencyDate'] = maxCompetencyDate;
            }

            if (ignoreInvoiceRelated !== undefined) {
                localVarQueryParameter['ignoreInvoiceRelated'] = ignoreInvoiceRelated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCashFlowReport: async (workspaceId: string, accountIds?: string, categoryIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetCashFlowReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/accounts/cash-flow`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (categoryIds !== undefined) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (costCenterIds !== undefined) {
                localVarQueryParameter['costCenterIds'] = costCenterIds;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (ignoreInternalTransfers !== undefined) {
                localVarQueryParameter['ignoreInternalTransfers'] = ignoreInternalTransfers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetFinancialStatementReport: async (workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetFinancialStatementReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/financial-statement`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (costCenterIds !== undefined) {
                localVarQueryParameter['costCenterIds'] = costCenterIds;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (minPostedDate !== undefined) {
                localVarQueryParameter['minPostedDate'] = minPostedDate;
            }

            if (maxPostedDate !== undefined) {
                localVarQueryParameter['maxPostedDate'] = maxPostedDate;
            }

            if (minCompetencyDate !== undefined) {
                localVarQueryParameter['minCompetencyDate'] = minCompetencyDate;
            }

            if (maxCompetencyDate !== undefined) {
                localVarQueryParameter['maxCompetencyDate'] = maxCompetencyDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetAccountsEntriesByCategoryReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowByCategoryReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetAccountsEntriesByCategoryReport(workspaceId, accountIds, costCenterIds, considerIgnored, ignoreInternalTransfers, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetAccountsEntriesByCategoryReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetAccountsOutputsByCategoryReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowByCategoryReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetAccountsOutputsByCategoryReport(workspaceId, accountIds, costCenterIds, considerIgnored, ignoreInternalTransfers, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetAccountsOutputsByCategoryReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetCardsCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInvoiceRelated?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetCardsCashFlowReport(workspaceId, accountIds, categoryIds, costCenterIds, considerIgnored, ignoreInvoiceRelated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetCardsCashFlowReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetCardsOutputsByCategoryReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, ignoreInvoiceRelated?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetCardsOutputsByCategoryReport(workspaceId, accountIds, costCenterIds, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, ignoreInvoiceRelated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetCardsOutputsByCategoryReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetCashFlowReport(workspaceId, accountIds, categoryIds, costCenterIds, considerIgnored, ignoreInternalTransfers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetCashFlowReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetFinancialStatementReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetFinancialStatementReport(workspaceId, accountIds, costCenterIds, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetFinancialStatementReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetAccountsEntriesByCategoryReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: any): AxiosPromise<CashFlowByCategoryReportEntity> {
            return localVarFp.reportsControllerGetAccountsEntriesByCategoryReport(workspaceId, accountIds, costCenterIds, considerIgnored, ignoreInternalTransfers, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetAccountsOutputsByCategoryReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: any): AxiosPromise<CashFlowByCategoryReportEntity> {
            return localVarFp.reportsControllerGetAccountsOutputsByCategoryReport(workspaceId, accountIds, costCenterIds, considerIgnored, ignoreInternalTransfers, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCardsCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInvoiceRelated?: boolean, options?: any): AxiosPromise<CashFlowReportEntity> {
            return localVarFp.reportsControllerGetCardsCashFlowReport(workspaceId, accountIds, categoryIds, costCenterIds, considerIgnored, ignoreInvoiceRelated, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCardsOutputsByCategoryReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, ignoreInvoiceRelated?: boolean, options?: any): AxiosPromise<CashFlowReportEntity> {
            return localVarFp.reportsControllerGetCardsOutputsByCategoryReport(workspaceId, accountIds, costCenterIds, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, ignoreInvoiceRelated, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, options?: any): AxiosPromise<CashFlowReportEntity> {
            return localVarFp.reportsControllerGetCashFlowReport(workspaceId, accountIds, categoryIds, costCenterIds, considerIgnored, ignoreInternalTransfers, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [costCenterIds] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetFinancialStatementReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: any): AxiosPromise<CashFlowReportEntity> {
            return localVarFp.reportsControllerGetFinancialStatementReport(workspaceId, accountIds, costCenterIds, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [costCenterIds] 
     * @param {boolean} [considerIgnored] 
     * @param {boolean} [ignoreInternalTransfers] 
     * @param {string} [minPostedDate] 
     * @param {string} [maxPostedDate] 
     * @param {string} [minCompetencyDate] 
     * @param {string} [maxCompetencyDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetAccountsEntriesByCategoryReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetAccountsEntriesByCategoryReport(workspaceId, accountIds, costCenterIds, considerIgnored, ignoreInternalTransfers, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [costCenterIds] 
     * @param {boolean} [considerIgnored] 
     * @param {boolean} [ignoreInternalTransfers] 
     * @param {string} [minPostedDate] 
     * @param {string} [maxPostedDate] 
     * @param {string} [minCompetencyDate] 
     * @param {string} [maxCompetencyDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetAccountsOutputsByCategoryReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetAccountsOutputsByCategoryReport(workspaceId, accountIds, costCenterIds, considerIgnored, ignoreInternalTransfers, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [categoryIds] 
     * @param {string} [costCenterIds] 
     * @param {boolean} [considerIgnored] 
     * @param {boolean} [ignoreInvoiceRelated] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetCardsCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInvoiceRelated?: boolean, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetCardsCashFlowReport(workspaceId, accountIds, categoryIds, costCenterIds, considerIgnored, ignoreInvoiceRelated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [costCenterIds] 
     * @param {boolean} [considerIgnored] 
     * @param {string} [minPostedDate] 
     * @param {string} [maxPostedDate] 
     * @param {string} [minCompetencyDate] 
     * @param {string} [maxCompetencyDate] 
     * @param {boolean} [ignoreInvoiceRelated] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetCardsOutputsByCategoryReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, ignoreInvoiceRelated?: boolean, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetCardsOutputsByCategoryReport(workspaceId, accountIds, costCenterIds, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, ignoreInvoiceRelated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [categoryIds] 
     * @param {string} [costCenterIds] 
     * @param {boolean} [considerIgnored] 
     * @param {boolean} [ignoreInternalTransfers] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, costCenterIds?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetCashFlowReport(workspaceId, accountIds, categoryIds, costCenterIds, considerIgnored, ignoreInternalTransfers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [costCenterIds] 
     * @param {boolean} [considerIgnored] 
     * @param {string} [minPostedDate] 
     * @param {string} [maxPostedDate] 
     * @param {string} [minCompetencyDate] 
     * @param {string} [maxCompetencyDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetFinancialStatementReport(workspaceId: string, accountIds?: string, costCenterIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetFinancialStatementReport(workspaceId, accountIds, costCenterIds, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateStripeCheckoutSessionRequestDto} createStripeCheckoutSessionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeControllerCreateCheckoutSessionForStripe: async (createStripeCheckoutSessionRequestDto: CreateStripeCheckoutSessionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createStripeCheckoutSessionRequestDto' is not null or undefined
            assertParamExists('stripeControllerCreateCheckoutSessionForStripe', 'createStripeCheckoutSessionRequestDto', createStripeCheckoutSessionRequestDto)
            const localVarPath = `/stripe/checkout-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createStripeCheckoutSessionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stripeSignature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeControllerStripeWebhook: async (stripeSignature: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stripeSignature' is not null or undefined
            assertParamExists('stripeControllerStripeWebhook', 'stripeSignature', stripeSignature)
            const localVarPath = `/stripe/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stripeSignature != null) {
                localVarHeaderParameter['stripe-signature'] = String(stripeSignature);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateStripeCheckoutSessionRequestDto} createStripeCheckoutSessionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeControllerCreateCheckoutSessionForStripe(createStripeCheckoutSessionRequestDto: CreateStripeCheckoutSessionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutSessionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeControllerCreateCheckoutSessionForStripe(createStripeCheckoutSessionRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.stripeControllerCreateCheckoutSessionForStripe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} stripeSignature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeControllerStripeWebhook(stripeSignature: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stripeControllerStripeWebhook(stripeSignature, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.stripeControllerStripeWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateStripeCheckoutSessionRequestDto} createStripeCheckoutSessionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeControllerCreateCheckoutSessionForStripe(createStripeCheckoutSessionRequestDto: CreateStripeCheckoutSessionRequestDto, options?: any): AxiosPromise<CheckoutSessionEntity> {
            return localVarFp.stripeControllerCreateCheckoutSessionForStripe(createStripeCheckoutSessionRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stripeSignature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeControllerStripeWebhook(stripeSignature: string, options?: any): AxiosPromise<void> {
            return localVarFp.stripeControllerStripeWebhook(stripeSignature, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * 
     * @param {CreateStripeCheckoutSessionRequestDto} createStripeCheckoutSessionRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeControllerCreateCheckoutSessionForStripe(createStripeCheckoutSessionRequestDto: CreateStripeCheckoutSessionRequestDto, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeControllerCreateCheckoutSessionForStripe(createStripeCheckoutSessionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stripeSignature 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public stripeControllerStripeWebhook(stripeSignature: string, options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).stripeControllerStripeWebhook(stripeSignature, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionProductsApi - axios parameter creator
 * @export
 */
export const SubscriptionProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionProductsControllerList: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('subscriptionProductsControllerList', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/subscription-products`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionProductsApi - functional programming interface
 * @export
 */
export const SubscriptionProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscriptionProductsControllerList(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionProductEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscriptionProductsControllerList(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionProductsApi.subscriptionProductsControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionProductsApi - factory interface
 * @export
 */
export const SubscriptionProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionProductsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscriptionProductsControllerList(workspaceId: string, options?: any): AxiosPromise<Array<SubscriptionProductEntity>> {
            return localVarFp.subscriptionProductsControllerList(workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionProductsApi - object-oriented interface
 * @export
 * @class SubscriptionProductsApi
 * @extends {BaseAPI}
 */
export class SubscriptionProductsApi extends BaseAPI {
    /**
     * 
     * @param {string} workspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionProductsApi
     */
    public subscriptionProductsControllerList(workspaceId: string, options?: RawAxiosRequestConfig) {
        return SubscriptionProductsApiFp(this.configuration).subscriptionProductsControllerList(workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspaceJoinRequestsApi - axios parameter creator
 * @export
 */
export const WorkspaceJoinRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceJoinRequestsControllerCreateNewPendingOrReturnCurrent: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspaceJoinRequestsControllerCreateNewPendingOrReturnCurrent', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/join-requests`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceJoinRequestsApi - functional programming interface
 * @export
 */
export const WorkspaceJoinRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceJoinRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceJoinRequestsControllerCreateNewPendingOrReturnCurrent(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceJoinRequestEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceJoinRequestsControllerCreateNewPendingOrReturnCurrent(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceJoinRequestsApi.workspaceJoinRequestsControllerCreateNewPendingOrReturnCurrent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspaceJoinRequestsApi - factory interface
 * @export
 */
export const WorkspaceJoinRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceJoinRequestsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceJoinRequestsControllerCreateNewPendingOrReturnCurrent(workspaceId: string, options?: any): AxiosPromise<WorkspaceJoinRequestEntity> {
            return localVarFp.workspaceJoinRequestsControllerCreateNewPendingOrReturnCurrent(workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceJoinRequestsApi - object-oriented interface
 * @export
 * @class WorkspaceJoinRequestsApi
 * @extends {BaseAPI}
 */
export class WorkspaceJoinRequestsApi extends BaseAPI {
    /**
     * 
     * @param {string} workspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceJoinRequestsApi
     */
    public workspaceJoinRequestsControllerCreateNewPendingOrReturnCurrent(workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceJoinRequestsApiFp(this.configuration).workspaceJoinRequestsControllerCreateNewPendingOrReturnCurrent(workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspaceSubscriptionsApi - axios parameter creator
 * @export
 */
export const WorkspaceSubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceSubscriptionsControllerGet: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspaceSubscriptionsControllerGet', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/subscription`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceSubscriptionsApi - functional programming interface
 * @export
 */
export const WorkspaceSubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceSubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceSubscriptionsControllerGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSubscriptionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceSubscriptionsControllerGet(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceSubscriptionsApi.workspaceSubscriptionsControllerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspaceSubscriptionsApi - factory interface
 * @export
 */
export const WorkspaceSubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceSubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceSubscriptionsControllerGet(workspaceId: string, options?: any): AxiosPromise<WorkspaceSubscriptionEntity> {
            return localVarFp.workspaceSubscriptionsControllerGet(workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceSubscriptionsApi - object-oriented interface
 * @export
 * @class WorkspaceSubscriptionsApi
 * @extends {BaseAPI}
 */
export class WorkspaceSubscriptionsApi extends BaseAPI {
    /**
     * 
     * @param {string} workspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceSubscriptionsApi
     */
    public workspaceSubscriptionsControllerGet(workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceSubscriptionsApiFp(this.configuration).workspaceSubscriptionsControllerGet(workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspacesApi - axios parameter creator
 * @export
 */
export const WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateWorkspaceRequestDto} createWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerCreate: async (createWorkspaceRequestDto: CreateWorkspaceRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkspaceRequestDto' is not null or undefined
            assertParamExists('workspacesControllerCreate', 'createWorkspaceRequestDto', createWorkspaceRequestDto)
            const localVarPath = `/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkspaceRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerFetchUserRelatedWorkspaces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspaces/related-to-me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerGet: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspacesControllerGet', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ParcialUpdateWorkspaceRequestDto} parcialUpdateWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerParcialUpdate: async (workspaceId: string, parcialUpdateWorkspaceRequestDto: ParcialUpdateWorkspaceRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspacesControllerParcialUpdate', 'workspaceId', workspaceId)
            // verify required parameter 'parcialUpdateWorkspaceRequestDto' is not null or undefined
            assertParamExists('workspacesControllerParcialUpdate', 'parcialUpdateWorkspaceRequestDto', parcialUpdateWorkspaceRequestDto)
            const localVarPath = `/workspaces/{workspaceId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parcialUpdateWorkspaceRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateWorkspaceRequestDto} createWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerCreate(createWorkspaceRequestDto: CreateWorkspaceRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllerCreate(createWorkspaceRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerFetchUserRelatedWorkspaces(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRelatedWorkspaceEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllerFetchUserRelatedWorkspaces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesControllerFetchUserRelatedWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerGet(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllerGet(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesControllerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ParcialUpdateWorkspaceRequestDto} parcialUpdateWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerParcialUpdate(workspaceId: string, parcialUpdateWorkspaceRequestDto: ParcialUpdateWorkspaceRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllerParcialUpdate(workspaceId, parcialUpdateWorkspaceRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesControllerParcialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspacesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateWorkspaceRequestDto} createWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerCreate(createWorkspaceRequestDto: CreateWorkspaceRequestDto, options?: any): AxiosPromise<WorkspaceEntity> {
            return localVarFp.workspacesControllerCreate(createWorkspaceRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerFetchUserRelatedWorkspaces(options?: any): AxiosPromise<Array<UserRelatedWorkspaceEntity>> {
            return localVarFp.workspacesControllerFetchUserRelatedWorkspaces(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerGet(workspaceId: string, options?: any): AxiosPromise<WorkspaceEntity> {
            return localVarFp.workspacesControllerGet(workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {ParcialUpdateWorkspaceRequestDto} parcialUpdateWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerParcialUpdate(workspaceId: string, parcialUpdateWorkspaceRequestDto: ParcialUpdateWorkspaceRequestDto, options?: any): AxiosPromise<WorkspaceEntity> {
            return localVarFp.workspacesControllerParcialUpdate(workspaceId, parcialUpdateWorkspaceRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
    /**
     * 
     * @param {CreateWorkspaceRequestDto} createWorkspaceRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesControllerCreate(createWorkspaceRequestDto: CreateWorkspaceRequestDto, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesControllerCreate(createWorkspaceRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesControllerFetchUserRelatedWorkspaces(options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesControllerFetchUserRelatedWorkspaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesControllerGet(workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesControllerGet(workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {ParcialUpdateWorkspaceRequestDto} parcialUpdateWorkspaceRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesControllerParcialUpdate(workspaceId: string, parcialUpdateWorkspaceRequestDto: ParcialUpdateWorkspaceRequestDto, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesControllerParcialUpdate(workspaceId, parcialUpdateWorkspaceRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



