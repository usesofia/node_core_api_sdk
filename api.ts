/* tslint:disable */
/* eslint-disable */
/**
 * Sofia Api
 * Api principal do sistema Sofia.
 *
 * The version of the OpenAPI document: 1.0.8
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AssignCategoryForBankTransactionsPageRequestDto
 */
export interface AssignCategoryForBankTransactionsPageRequestDto {
    /**
     * 
     * @type {string}
     * @memberof AssignCategoryForBankTransactionsPageRequestDto
     */
    'syncItemId': string;
    /**
     * 
     * @type {number}
     * @memberof AssignCategoryForBankTransactionsPageRequestDto
     */
    'pageNumber': number;
    /**
     * 
     * @type {SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage}
     * @memberof AssignCategoryForBankTransactionsPageRequestDto
     */
    'bankProviderTransactionsPage': SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage;
    /**
     * 
     * @type {Array<SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInner>}
     * @memberof AssignCategoryForBankTransactionsPageRequestDto
     */
    'legalNatureAssignRequests': Array<SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInner>;
}
/**
 * 
 * @export
 * @interface AssignLegalNatureForBankTransactionsPageRequestDto
 */
export interface AssignLegalNatureForBankTransactionsPageRequestDto {
    /**
     * 
     * @type {string}
     * @memberof AssignLegalNatureForBankTransactionsPageRequestDto
     */
    'syncItemId': string;
    /**
     * 
     * @type {number}
     * @memberof AssignLegalNatureForBankTransactionsPageRequestDto
     */
    'pageNumber': number;
    /**
     * 
     * @type {SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage}
     * @memberof AssignLegalNatureForBankTransactionsPageRequestDto
     */
    'bankProviderTransactionsPage': SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage;
}
/**
 * 
 * @export
 * @interface BalancePointResultEntity
 */
export interface BalancePointResultEntity {
    /**
     * 
     * @type {number}
     * @memberof BalancePointResultEntity
     */
    'amountInCents'?: number;
}
/**
 * 
 * @export
 * @interface BankAccountEntity
 */
export interface BankAccountEntity {
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'bankConnectionId': string;
    /**
     * 
     * @type {BankTransactionEntityAccountBankConnection}
     * @memberof BankAccountEntity
     */
    'bankConnection': BankTransactionEntityAccountBankConnection;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'provider': BankAccountEntityProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'providerAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'type': BankAccountEntityTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof BankAccountEntity
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof BankAccountEntity
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'currencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountEntity
     */
    'updatedAt': string;
}

export const BankAccountEntityProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type BankAccountEntityProviderEnum = typeof BankAccountEntityProviderEnum[keyof typeof BankAccountEntityProviderEnum];
export const BankAccountEntityTypeEnum = {
    Checking: 'CHECKING',
    Savings: 'SAVINGS',
    CreditCard: 'CREDIT_CARD'
} as const;

export type BankAccountEntityTypeEnum = typeof BankAccountEntityTypeEnum[keyof typeof BankAccountEntityTypeEnum];

/**
 * 
 * @export
 * @interface BankAccountsBalanceReportEntity
 */
export interface BankAccountsBalanceReportEntity {
    /**
     * 
     * @type {Array<BankAccountsBalanceReportEntityItemsInner>}
     * @memberof BankAccountsBalanceReportEntity
     */
    'items': Array<BankAccountsBalanceReportEntityItemsInner>;
    /**
     * 
     * @type {Array<BankTransactionEntityAccount>}
     * @memberof BankAccountsBalanceReportEntity
     */
    'bankAccounts': Array<BankTransactionEntityAccount>;
}
/**
 * 
 * @export
 * @interface BankAccountsBalanceReportEntityItemsInner
 */
export interface BankAccountsBalanceReportEntityItemsInner {
    /**
     * 
     * @type {number}
     * @memberof BankAccountsBalanceReportEntityItemsInner
     */
    'totalBalance': number;
    /**
     * 
     * @type {string}
     * @memberof BankAccountsBalanceReportEntityItemsInner
     */
    'currencyCode': string;
}
/**
 * 
 * @export
 * @interface BankConnectionEntity
 */
export interface BankConnectionEntity {
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'workspaceId': string;
    /**
     * 
     * @type {Array<BankConnectionEntityAccountsInner>}
     * @memberof BankConnectionEntity
     */
    'accounts'?: Array<BankConnectionEntityAccountsInner> | null;
    /**
     * 
     * @type {boolean}
     * @memberof BankConnectionEntity
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'provider': BankConnectionEntityProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'providerItemId': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'historyRange': BankConnectionEntityHistoryRangeEnum;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'connectorId': string;
    /**
     * 
     * @type {BankConnectionEntityConnector}
     * @memberof BankConnectionEntity
     */
    'connector'?: BankConnectionEntityConnector | null;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntity
     */
    'updatedAt': string;
}

export const BankConnectionEntityProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type BankConnectionEntityProviderEnum = typeof BankConnectionEntityProviderEnum[keyof typeof BankConnectionEntityProviderEnum];
export const BankConnectionEntityHistoryRangeEnum = {
    OneDay: 'ONE_DAY',
    OneWeek: 'ONE_WEEK',
    OneMonth: 'ONE_MONTH',
    TwoMonths: 'TWO_MONTHS',
    ThreeMonths: 'THREE_MONTHS',
    SixMonths: 'SIX_MONTHS',
    OneYear: 'ONE_YEAR'
} as const;

export type BankConnectionEntityHistoryRangeEnum = typeof BankConnectionEntityHistoryRangeEnum[keyof typeof BankConnectionEntityHistoryRangeEnum];

/**
 * 
 * @export
 * @interface BankConnectionEntityAccountsInner
 */
export interface BankConnectionEntityAccountsInner {
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityAccountsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityAccountsInner
     */
    'bankConnectionId': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityAccountsInner
     */
    'provider': BankConnectionEntityAccountsInnerProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityAccountsInner
     */
    'providerAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityAccountsInner
     */
    'type': BankConnectionEntityAccountsInnerTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof BankConnectionEntityAccountsInner
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityAccountsInner
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof BankConnectionEntityAccountsInner
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityAccountsInner
     */
    'currencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityAccountsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityAccountsInner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityAccountsInner
     */
    'updatedAt': string;
}

export const BankConnectionEntityAccountsInnerProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type BankConnectionEntityAccountsInnerProviderEnum = typeof BankConnectionEntityAccountsInnerProviderEnum[keyof typeof BankConnectionEntityAccountsInnerProviderEnum];
export const BankConnectionEntityAccountsInnerTypeEnum = {
    Checking: 'CHECKING',
    Savings: 'SAVINGS',
    CreditCard: 'CREDIT_CARD'
} as const;

export type BankConnectionEntityAccountsInnerTypeEnum = typeof BankConnectionEntityAccountsInnerTypeEnum[keyof typeof BankConnectionEntityAccountsInnerTypeEnum];

/**
 * 
 * @export
 * @interface BankConnectionEntityConnector
 */
export interface BankConnectionEntityConnector {
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityConnector
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityConnector
     */
    'provider': BankConnectionEntityConnectorProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityConnector
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityConnector
     */
    'institutionUrl': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityConnector
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityConnector
     */
    'primaryColor': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityConnector
     */
    'type': BankConnectionEntityConnectorTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityConnector
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityConnector
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankConnectionEntityConnector
     */
    'updatedAt': string;
}

export const BankConnectionEntityConnectorProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type BankConnectionEntityConnectorProviderEnum = typeof BankConnectionEntityConnectorProviderEnum[keyof typeof BankConnectionEntityConnectorProviderEnum];
export const BankConnectionEntityConnectorTypeEnum = {
    PersonalBank: 'PERSONAL_BANK',
    BusinessBank: 'BUSINESS_BANK',
    Investment: 'INVESTMENT',
    DigitalEconomy: 'DIGITAL_ECONOMY',
    Other: 'OTHER'
} as const;

export type BankConnectionEntityConnectorTypeEnum = typeof BankConnectionEntityConnectorTypeEnum[keyof typeof BankConnectionEntityConnectorTypeEnum];

/**
 * 
 * @export
 * @interface BankTransactionCategoryEntity
 */
export interface BankTransactionCategoryEntity {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntity
     */
    'directionNature': BankTransactionCategoryEntityDirectionNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntity
     */
    'parentId'?: string | null;
    /**
     * 
     * @type {Array<BankTransactionCategoryEntityChildrenInner>}
     * @memberof BankTransactionCategoryEntity
     */
    'children': Array<BankTransactionCategoryEntityChildrenInner>;
}

export const BankTransactionCategoryEntityDirectionNatureEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    Undefined: 'UNDEFINED'
} as const;

export type BankTransactionCategoryEntityDirectionNatureEnum = typeof BankTransactionCategoryEntityDirectionNatureEnum[keyof typeof BankTransactionCategoryEntityDirectionNatureEnum];

/**
 * 
 * @export
 * @interface BankTransactionCategoryEntityChildrenInner
 */
export interface BankTransactionCategoryEntityChildrenInner {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntityChildrenInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntityChildrenInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntityChildrenInner
     */
    'directionNature': BankTransactionCategoryEntityChildrenInnerDirectionNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionCategoryEntityChildrenInner
     */
    'parentId'?: string | null;
}

export const BankTransactionCategoryEntityChildrenInnerDirectionNatureEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    Undefined: 'UNDEFINED'
} as const;

export type BankTransactionCategoryEntityChildrenInnerDirectionNatureEnum = typeof BankTransactionCategoryEntityChildrenInnerDirectionNatureEnum[keyof typeof BankTransactionCategoryEntityChildrenInnerDirectionNatureEnum];

/**
 * 
 * @export
 * @interface BankTransactionEntity
 */
export interface BankTransactionEntity {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'accountId': string;
    /**
     * 
     * @type {BankTransactionEntityAccount}
     * @memberof BankTransactionEntity
     */
    'account': BankTransactionEntityAccount;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'provider': BankTransactionEntityProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'providerTransactionId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'originalDescription': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'postedDate': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'competencyDate': string;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionEntity
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'directionNature': BankTransactionEntityDirectionNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'status': BankTransactionEntityStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'legalNature': BankTransactionEntityLegalNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'providerCategoryId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'providerCategoryName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'categoryId'?: string | null;
    /**
     * 
     * @type {BankTransactionEntityCategory}
     * @memberof BankTransactionEntity
     */
    'category'?: BankTransactionEntityCategory | null;
    /**
     * 
     * @type {Array<BankTransactionEntityTagsInner>}
     * @memberof BankTransactionEntity
     */
    'tags': Array<BankTransactionEntityTagsInner>;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'paymentDataId'?: string | null;
    /**
     * 
     * @type {BankTransactionEntityPaymentData}
     * @memberof BankTransactionEntity
     */
    'paymentData'?: BankTransactionEntityPaymentData | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'creditCardMetadataId'?: string | null;
    /**
     * 
     * @type {BankTransactionEntityCreditCardMetadata}
     * @memberof BankTransactionEntity
     */
    'creditCardMetadata'?: BankTransactionEntityCreditCardMetadata | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'ignoredAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'verifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntity
     */
    'updatedAt': string;
}

export const BankTransactionEntityProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type BankTransactionEntityProviderEnum = typeof BankTransactionEntityProviderEnum[keyof typeof BankTransactionEntityProviderEnum];
export const BankTransactionEntityDirectionNatureEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    Undefined: 'UNDEFINED'
} as const;

export type BankTransactionEntityDirectionNatureEnum = typeof BankTransactionEntityDirectionNatureEnum[keyof typeof BankTransactionEntityDirectionNatureEnum];
export const BankTransactionEntityStatusEnum = {
    Pending: 'PENDING',
    Posted: 'POSTED'
} as const;

export type BankTransactionEntityStatusEnum = typeof BankTransactionEntityStatusEnum[keyof typeof BankTransactionEntityStatusEnum];
export const BankTransactionEntityLegalNatureEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Undefined: 'UNDEFINED'
} as const;

export type BankTransactionEntityLegalNatureEnum = typeof BankTransactionEntityLegalNatureEnum[keyof typeof BankTransactionEntityLegalNatureEnum];

/**
 * 
 * @export
 * @interface BankTransactionEntityAccount
 */
export interface BankTransactionEntityAccount {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccount
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccount
     */
    'bankConnectionId': string;
    /**
     * 
     * @type {BankTransactionEntityAccountBankConnection}
     * @memberof BankTransactionEntityAccount
     */
    'bankConnection': BankTransactionEntityAccountBankConnection;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccount
     */
    'provider': BankTransactionEntityAccountProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccount
     */
    'providerAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccount
     */
    'type': BankTransactionEntityAccountTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof BankTransactionEntityAccount
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccount
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionEntityAccount
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccount
     */
    'currencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccount
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccount
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccount
     */
    'updatedAt': string;
}

export const BankTransactionEntityAccountProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type BankTransactionEntityAccountProviderEnum = typeof BankTransactionEntityAccountProviderEnum[keyof typeof BankTransactionEntityAccountProviderEnum];
export const BankTransactionEntityAccountTypeEnum = {
    Checking: 'CHECKING',
    Savings: 'SAVINGS',
    CreditCard: 'CREDIT_CARD'
} as const;

export type BankTransactionEntityAccountTypeEnum = typeof BankTransactionEntityAccountTypeEnum[keyof typeof BankTransactionEntityAccountTypeEnum];

/**
 * 
 * @export
 * @interface BankTransactionEntityAccountBankConnection
 */
export interface BankTransactionEntityAccountBankConnection {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'workspaceId': string;
    /**
     * 
     * @type {boolean}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'provider': BankTransactionEntityAccountBankConnectionProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'providerItemId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'historyRange': BankTransactionEntityAccountBankConnectionHistoryRangeEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'connectorId': string;
    /**
     * 
     * @type {BankConnectionEntityConnector}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'connector'?: BankConnectionEntityConnector | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityAccountBankConnection
     */
    'updatedAt': string;
}

export const BankTransactionEntityAccountBankConnectionProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type BankTransactionEntityAccountBankConnectionProviderEnum = typeof BankTransactionEntityAccountBankConnectionProviderEnum[keyof typeof BankTransactionEntityAccountBankConnectionProviderEnum];
export const BankTransactionEntityAccountBankConnectionHistoryRangeEnum = {
    OneDay: 'ONE_DAY',
    OneWeek: 'ONE_WEEK',
    OneMonth: 'ONE_MONTH',
    TwoMonths: 'TWO_MONTHS',
    ThreeMonths: 'THREE_MONTHS',
    SixMonths: 'SIX_MONTHS',
    OneYear: 'ONE_YEAR'
} as const;

export type BankTransactionEntityAccountBankConnectionHistoryRangeEnum = typeof BankTransactionEntityAccountBankConnectionHistoryRangeEnum[keyof typeof BankTransactionEntityAccountBankConnectionHistoryRangeEnum];

/**
 * 
 * @export
 * @interface BankTransactionEntityCategory
 */
export interface BankTransactionEntityCategory {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityCategory
     */
    'directionNature': BankTransactionEntityCategoryDirectionNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityCategory
     */
    'parentId'?: string | null;
}

export const BankTransactionEntityCategoryDirectionNatureEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    Undefined: 'UNDEFINED'
} as const;

export type BankTransactionEntityCategoryDirectionNatureEnum = typeof BankTransactionEntityCategoryDirectionNatureEnum[keyof typeof BankTransactionEntityCategoryDirectionNatureEnum];

/**
 * 
 * @export
 * @interface BankTransactionEntityCreditCardMetadata
 */
export interface BankTransactionEntityCreditCardMetadata {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityCreditCardMetadata
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityCreditCardMetadata
     */
    'transactionId': string;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionEntityCreditCardMetadata
     */
    'installmentNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionEntityCreditCardMetadata
     */
    'totalInstallments'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionEntityCreditCardMetadata
     */
    'totalAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionEntityCreditCardMetadata
     */
    'payeeMCC'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityCreditCardMetadata
     */
    'cardNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityCreditCardMetadata
     */
    'billId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityCreditCardMetadata
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityCreditCardMetadata
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankTransactionEntityPaymentData
 */
export interface BankTransactionEntityPaymentData {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'transactionId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'payerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'payerBranchNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'payerAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'payerRoutingNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'payerRoutingNumberISPB'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'payerDocumentNumberType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'payerDocumentNumberValue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'reason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'receiverName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'receiverBranchNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'receiverAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'receiverRoutingNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'receiverRoutingNumberISPB'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'receiverDocumentNumberType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'receiverDocumentNumberValue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'paymentMethod'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'referenceNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'receiverReferenceId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityPaymentData
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankTransactionEntityTagsInner
 */
export interface BankTransactionEntityTagsInner {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityTagsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityTagsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityTagsInner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionEntityTagsInner
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankTransactionIndicatorEntity
 */
export interface BankTransactionIndicatorEntity {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionIndicatorEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionIndicatorEntity
     */
    'prettyId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionIndicatorEntity
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionIndicatorEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionIndicatorEntity
     */
    'description': string;
    /**
     * 
     * @type {object}
     * @memberof BankTransactionIndicatorEntity
     */
    'data': object;
    /**
     * 
     * @type {DreLineOutcomeResultEntity}
     * @memberof BankTransactionIndicatorEntity
     */
    'dreLineOutcomeResult'?: DreLineOutcomeResultEntity;
    /**
     * 
     * @type {BalancePointResultEntity}
     * @memberof BankTransactionIndicatorEntity
     */
    'balancePointResult'?: BalancePointResultEntity;
    /**
     * 
     * @type {MeanResultEntity}
     * @memberof BankTransactionIndicatorEntity
     */
    'meanResult'?: MeanResultEntity;
    /**
     * 
     * @type {ProportionResultEntity}
     * @memberof BankTransactionIndicatorEntity
     */
    'proportionResult'?: ProportionResultEntity;
}
/**
 * 
 * @export
 * @interface BankTransactionTagEntity
 */
export interface BankTransactionTagEntity {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionTagEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionTagEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionTagEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionTagEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface BankTransactionsPageEntity
 */
export interface BankTransactionsPageEntity {
    /**
     * 
     * @type {number}
     * @memberof BankTransactionsPageEntity
     */
    'pageIndex': number;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionsPageEntity
     */
    'pageSize': number;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionsPageEntity
     */
    'totalItems': number;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionsPageEntity
     */
    'totalPages': number;
    /**
     * 
     * @type {Array<BankTransactionsPageEntityItemsInner>}
     * @memberof BankTransactionsPageEntity
     */
    'items': Array<BankTransactionsPageEntityItemsInner>;
}
/**
 * 
 * @export
 * @interface BankTransactionsPageEntityItemsInner
 */
export interface BankTransactionsPageEntityItemsInner {
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'accountId': string;
    /**
     * 
     * @type {BankTransactionEntityAccount}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'account': BankTransactionEntityAccount;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'provider': BankTransactionsPageEntityItemsInnerProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'providerTransactionId': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'originalDescription': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'postedDate': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'competencyDate': string;
    /**
     * 
     * @type {number}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'directionNature': BankTransactionsPageEntityItemsInnerDirectionNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'status': BankTransactionsPageEntityItemsInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'legalNature': BankTransactionsPageEntityItemsInnerLegalNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'providerCategoryId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'providerCategoryName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'categoryId'?: string | null;
    /**
     * 
     * @type {BankTransactionEntityCategory}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'category'?: BankTransactionEntityCategory | null;
    /**
     * 
     * @type {Array<BankTransactionEntityTagsInner>}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'tags': Array<BankTransactionEntityTagsInner>;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'paymentDataId'?: string | null;
    /**
     * 
     * @type {BankTransactionEntityPaymentData}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'paymentData'?: BankTransactionEntityPaymentData | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'creditCardMetadataId'?: string | null;
    /**
     * 
     * @type {BankTransactionEntityCreditCardMetadata}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'creditCardMetadata'?: BankTransactionEntityCreditCardMetadata | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'ignoredAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'verifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankTransactionsPageEntityItemsInner
     */
    'updatedAt': string;
}

export const BankTransactionsPageEntityItemsInnerProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type BankTransactionsPageEntityItemsInnerProviderEnum = typeof BankTransactionsPageEntityItemsInnerProviderEnum[keyof typeof BankTransactionsPageEntityItemsInnerProviderEnum];
export const BankTransactionsPageEntityItemsInnerDirectionNatureEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    Undefined: 'UNDEFINED'
} as const;

export type BankTransactionsPageEntityItemsInnerDirectionNatureEnum = typeof BankTransactionsPageEntityItemsInnerDirectionNatureEnum[keyof typeof BankTransactionsPageEntityItemsInnerDirectionNatureEnum];
export const BankTransactionsPageEntityItemsInnerStatusEnum = {
    Pending: 'PENDING',
    Posted: 'POSTED'
} as const;

export type BankTransactionsPageEntityItemsInnerStatusEnum = typeof BankTransactionsPageEntityItemsInnerStatusEnum[keyof typeof BankTransactionsPageEntityItemsInnerStatusEnum];
export const BankTransactionsPageEntityItemsInnerLegalNatureEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Undefined: 'UNDEFINED'
} as const;

export type BankTransactionsPageEntityItemsInnerLegalNatureEnum = typeof BankTransactionsPageEntityItemsInnerLegalNatureEnum[keyof typeof BankTransactionsPageEntityItemsInnerLegalNatureEnum];

/**
 * 
 * @export
 * @interface CashFlowByCategoryReportEntity
 */
export interface CashFlowByCategoryReportEntity {
    /**
     * 
     * @type {Array<CashFlowByCategoryReportItemEntity>}
     * @memberof CashFlowByCategoryReportEntity
     */
    'items': Array<CashFlowByCategoryReportItemEntity>;
}
/**
 * 
 * @export
 * @interface CashFlowByCategoryReportItemEntity
 */
export interface CashFlowByCategoryReportItemEntity {
    /**
     * 
     * @type {string}
     * @memberof CashFlowByCategoryReportItemEntity
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowByCategoryReportItemEntity
     */
    'categoryName': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowByCategoryReportItemEntity
     */
    'absoluteValue': number;
    /**
     * 
     * @type {number}
     * @memberof CashFlowByCategoryReportItemEntity
     */
    'percentage': number;
}
/**
 * 
 * @export
 * @interface CashFlowReportDailyItemEntity
 */
export interface CashFlowReportDailyItemEntity {
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportDailyItemEntity
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportDailyItemEntity
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportDailyItemEntity
     */
    'dayOfYear': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportDailyItemEntity
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportDailyItemEntity
     */
    'minDate': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportDailyItemEntity
     */
    'maxDate': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportDailyItemEntity
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CashFlowReportEntity
 */
export interface CashFlowReportEntity {
    /**
     * 
     * @type {Array<CashFlowReportDailyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'dailyBalanceItems': Array<CashFlowReportDailyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportDailyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'dailyPostedIncomeItems': Array<CashFlowReportDailyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportDailyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'dailyCompetencyIncomeItems': Array<CashFlowReportDailyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportDailyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'dailyPostedOutcomeItems': Array<CashFlowReportDailyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportDailyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'dailyCompetencyOutcomeItems': Array<CashFlowReportDailyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportWeeklyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'weeklyBalanceItems': Array<CashFlowReportWeeklyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportWeeklyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'weeklyPostedIncomeItems': Array<CashFlowReportWeeklyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportWeeklyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'weeklyCompetencyIncomeItems': Array<CashFlowReportWeeklyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportWeeklyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'weeklyPostedOutcomeItems': Array<CashFlowReportWeeklyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportWeeklyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'weeklyCompetencyOutcomeItems': Array<CashFlowReportWeeklyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportMonthlyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'monthlyBalanceItems': Array<CashFlowReportMonthlyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportMonthlyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'monthlyPostedIncomeItems': Array<CashFlowReportMonthlyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportMonthlyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'monthlyCompetencyIncomeItems': Array<CashFlowReportMonthlyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportMonthlyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'monthlyPostedOutcomeItems': Array<CashFlowReportMonthlyItemEntity>;
    /**
     * 
     * @type {Array<CashFlowReportMonthlyItemEntity>}
     * @memberof CashFlowReportEntity
     */
    'monthlyCompetencyOutcomeItems': Array<CashFlowReportMonthlyItemEntity>;
}
/**
 * 
 * @export
 * @interface CashFlowReportMonthlyItemEntity
 */
export interface CashFlowReportMonthlyItemEntity {
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'month': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'minDate': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'maxDate': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportMonthlyItemEntity
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CashFlowReportWeeklyItemEntity
 */
export interface CashFlowReportWeeklyItemEntity {
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'index': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'week': number;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'minDate': string;
    /**
     * 
     * @type {string}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'maxDate': string;
    /**
     * 
     * @type {number}
     * @memberof CashFlowReportWeeklyItemEntity
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface CreateBankTransactionTagRequestDto
 */
export interface CreateBankTransactionTagRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateBankTransactionTagRequestDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateBankAccountRequestDto
 */
export interface CreateOrUpdateBankAccountRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'bankConnectionId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'provider': CreateOrUpdateBankAccountRequestDtoProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'providerAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'type': CreateOrUpdateBankAccountRequestDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'number': string;
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'currencyCode': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankAccountRequestDto
     */
    'name': string;
}

export const CreateOrUpdateBankAccountRequestDtoProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type CreateOrUpdateBankAccountRequestDtoProviderEnum = typeof CreateOrUpdateBankAccountRequestDtoProviderEnum[keyof typeof CreateOrUpdateBankAccountRequestDtoProviderEnum];
export const CreateOrUpdateBankAccountRequestDtoTypeEnum = {
    Checking: 'CHECKING',
    Savings: 'SAVINGS',
    CreditCard: 'CREDIT_CARD'
} as const;

export type CreateOrUpdateBankAccountRequestDtoTypeEnum = typeof CreateOrUpdateBankAccountRequestDtoTypeEnum[keyof typeof CreateOrUpdateBankAccountRequestDtoTypeEnum];

/**
 * 
 * @export
 * @interface CreateOrUpdateBankConnectionRequestDto
 */
export interface CreateOrUpdateBankConnectionRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankConnectionRequestDto
     */
    'createdByUserId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankConnectionRequestDto
     */
    'provider': CreateOrUpdateBankConnectionRequestDtoProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankConnectionRequestDto
     */
    'providerItemId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankConnectionRequestDto
     */
    'providerConnectorId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankConnectionRequestDto
     */
    'historyRange': CreateOrUpdateBankConnectionRequestDtoHistoryRangeEnum;
}

export const CreateOrUpdateBankConnectionRequestDtoProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type CreateOrUpdateBankConnectionRequestDtoProviderEnum = typeof CreateOrUpdateBankConnectionRequestDtoProviderEnum[keyof typeof CreateOrUpdateBankConnectionRequestDtoProviderEnum];
export const CreateOrUpdateBankConnectionRequestDtoHistoryRangeEnum = {
    OneDay: 'ONE_DAY',
    OneWeek: 'ONE_WEEK',
    OneMonth: 'ONE_MONTH',
    TwoMonths: 'TWO_MONTHS',
    ThreeMonths: 'THREE_MONTHS',
    SixMonths: 'SIX_MONTHS',
    OneYear: 'ONE_YEAR'
} as const;

export type CreateOrUpdateBankConnectionRequestDtoHistoryRangeEnum = typeof CreateOrUpdateBankConnectionRequestDtoHistoryRangeEnum[keyof typeof CreateOrUpdateBankConnectionRequestDtoHistoryRangeEnum];

/**
 * 
 * @export
 * @interface CreateOrUpdateBankTransactionsInBulkRequestDto
 */
export interface CreateOrUpdateBankTransactionsInBulkRequestDto {
    /**
     * 
     * @type {Array<CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner>}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDto
     */
    'items': Array<CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner>;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
 */
export interface CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'provider': CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'providerTransactionId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'postedDate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'competencyDate': string;
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'directionNature': CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerDirectionNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'status': CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'legalNature': CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'providerCategoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'providerCategoryName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'categoryId'?: string;
    /**
     * 
     * @type {CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'paymentData'?: CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData;
    /**
     * 
     * @type {CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCreditCardMetadata}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'creditCardMetadata'?: CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCreditCardMetadata;
    /**
     * 
     * @type {Array<CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCategoryGuessesInner>}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'categoryGuesses'?: Array<CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCategoryGuessesInner>;
    /**
     * 
     * @type {Array<CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInner>}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInner
     */
    'legalNatureGuesses'?: Array<CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInner>;
}

export const CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerProviderEnum = typeof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerProviderEnum[keyof typeof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerProviderEnum];
export const CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerDirectionNatureEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    Undefined: 'UNDEFINED'
} as const;

export type CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerDirectionNatureEnum = typeof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerDirectionNatureEnum[keyof typeof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerDirectionNatureEnum];
export const CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerStatusEnum = {
    Pending: 'PENDING',
    Posted: 'POSTED'
} as const;

export type CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerStatusEnum = typeof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerStatusEnum[keyof typeof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerStatusEnum];
export const CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Undefined: 'UNDEFINED'
} as const;

export type CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureEnum = typeof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureEnum[keyof typeof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureEnum];

/**
 * 
 * @export
 * @interface CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCategoryGuessesInner
 */
export interface CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCategoryGuessesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCategoryGuessesInner
     */
    'categoryId': string;
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCategoryGuessesInner
     */
    'confidenceScore': number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCategoryGuessesInner
     */
    'guesserModelId': string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCreditCardMetadata
 */
export interface CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCreditCardMetadata {
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCreditCardMetadata
     */
    'installmentNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCreditCardMetadata
     */
    'totalInstallments'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCreditCardMetadata
     */
    'totalAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCreditCardMetadata
     */
    'payeeMCC'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCreditCardMetadata
     */
    'cardNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCreditCardMetadata
     */
    'billId'?: string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInner
 */
export interface CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInner {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInner
     */
    'legalNature': CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInnerLegalNatureEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInner
     */
    'confidenceScore': number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInner
     */
    'guesserModelId': string;
}

export const CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInnerLegalNatureEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Undefined: 'UNDEFINED'
} as const;

export type CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInnerLegalNatureEnum = typeof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInnerLegalNatureEnum[keyof typeof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInnerLegalNatureEnum];

/**
 * 
 * @export
 * @interface CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
 */
export interface CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'payerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'payerBranchNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'payerAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'payerRoutingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'payerRoutingNumberISPB'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'payerDocumentNumberType'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'payerDocumentNumberValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'receiverName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'receiverBranchNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'receiverAccountNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'receiverRoutingNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'receiverRoutingNumberISPB'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'receiverDocumentNumberType'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'receiverDocumentNumberValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'paymentMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'referenceNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerPaymentData
     */
    'receiverReferenceId'?: string;
}
/**
 * 
 * @export
 * @interface CreateOrUpdateMessageTokenRequestDto
 */
export interface CreateOrUpdateMessageTokenRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateMessageTokenRequestDto
     */
    'platform': CreateOrUpdateMessageTokenRequestDtoPlatformEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateMessageTokenRequestDto
     */
    'provider': CreateOrUpdateMessageTokenRequestDtoProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateMessageTokenRequestDto
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateMessageTokenRequestDto
     */
    'token': string;
}

export const CreateOrUpdateMessageTokenRequestDtoPlatformEnum = {
    Web: 'WEB',
    Android: 'ANDROID',
    Ios: 'IOS'
} as const;

export type CreateOrUpdateMessageTokenRequestDtoPlatformEnum = typeof CreateOrUpdateMessageTokenRequestDtoPlatformEnum[keyof typeof CreateOrUpdateMessageTokenRequestDtoPlatformEnum];
export const CreateOrUpdateMessageTokenRequestDtoProviderEnum = {
    FirebaseMessaging: 'FIREBASE_MESSAGING'
} as const;

export type CreateOrUpdateMessageTokenRequestDtoProviderEnum = typeof CreateOrUpdateMessageTokenRequestDtoProviderEnum[keyof typeof CreateOrUpdateMessageTokenRequestDtoProviderEnum];

/**
 * 
 * @export
 * @interface CreatePluggyConnectTokenRequestDto
 */
export interface CreatePluggyConnectTokenRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePluggyConnectTokenRequestDto
     */
    'itemId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePluggyConnectTokenRequestDto
     */
    'workspaceId': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePluggyConnectTokenRequestDto
     */
    'historyRange': CreatePluggyConnectTokenRequestDtoHistoryRangeEnum;
}

export const CreatePluggyConnectTokenRequestDtoHistoryRangeEnum = {
    OneDay: 'ONE_DAY',
    OneWeek: 'ONE_WEEK',
    OneMonth: 'ONE_MONTH',
    TwoMonths: 'TWO_MONTHS',
    ThreeMonths: 'THREE_MONTHS',
    SixMonths: 'SIX_MONTHS',
    OneYear: 'ONE_YEAR'
} as const;

export type CreatePluggyConnectTokenRequestDtoHistoryRangeEnum = typeof CreatePluggyConnectTokenRequestDtoHistoryRangeEnum[keyof typeof CreatePluggyConnectTokenRequestDtoHistoryRangeEnum];

/**
 * 
 * @export
 * @interface CreateProfileRequestDto
 */
export interface CreateProfileRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequestDto
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequestDto
     */
    'birthDate': string;
}
/**
 * 
 * @export
 * @interface CreateWorkspaceRequestDto
 */
export interface CreateWorkspaceRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceRequestDto
     */
    'prettyId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceRequestDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceRequestDto
     */
    'type': CreateWorkspaceRequestDtoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceRequestDto
     */
    'businessSegment'?: CreateWorkspaceRequestDtoBusinessSegmentEnum | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWorkspaceRequestDto
     */
    'otherDescription'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWorkspaceRequestDto
     */
    'throwAfterCreateWorkspace'?: boolean | null;
}

export const CreateWorkspaceRequestDtoTypeEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Hybrid: 'HYBRID'
} as const;

export type CreateWorkspaceRequestDtoTypeEnum = typeof CreateWorkspaceRequestDtoTypeEnum[keyof typeof CreateWorkspaceRequestDtoTypeEnum];
export const CreateWorkspaceRequestDtoBusinessSegmentEnum = {
    Attorney: 'ATTORNEY',
    Architect: 'ARCHITECT',
    Consultant: 'CONSULTANT',
    Realtor: 'REALTOR',
    InsuranceBroker: 'INSURANCE_BROKER',
    Dentist: 'DENTIST',
    Physiotherapist: 'PHYSIOTHERAPIST',
    Physician: 'PHYSICIAN',
    Tutor: 'TUTOR',
    Psychologist: 'PSYCHOLOGIST',
    Other: 'OTHER'
} as const;

export type CreateWorkspaceRequestDtoBusinessSegmentEnum = typeof CreateWorkspaceRequestDtoBusinessSegmentEnum[keyof typeof CreateWorkspaceRequestDtoBusinessSegmentEnum];

/**
 * 
 * @export
 * @interface CredentialsEntity
 */
export interface CredentialsEntity {
    /**
     * 
     * @type {string}
     * @memberof CredentialsEntity
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialsEntity
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof CredentialsEntity
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface DreLineOutcomeResultEntity
 */
export interface DreLineOutcomeResultEntity {
    /**
     * 
     * @type {number}
     * @memberof DreLineOutcomeResultEntity
     */
    'amountInCents': number;
    /**
     * 
     * @type {number}
     * @memberof DreLineOutcomeResultEntity
     */
    'ratio'?: number;
}
/**
 * 
 * @export
 * @interface EmailInUseReportEntity
 */
export interface EmailInUseReportEntity {
    /**
     * 
     * @type {string}
     * @memberof EmailInUseReportEntity
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof EmailInUseReportEntity
     */
    'inUse': boolean;
}
/**
 * 
 * @export
 * @interface ExceptionResponseEntity
 */
export interface ExceptionResponseEntity {
    /**
     * 
     * @type {number}
     * @memberof ExceptionResponseEntity
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof ExceptionResponseEntity
     */
    'message': string;
    /**
     * 
     * @type {Array<ExceptionResponseEntityErrorsInner>}
     * @memberof ExceptionResponseEntity
     */
    'errors': Array<ExceptionResponseEntityErrorsInner>;
}
/**
 * 
 * @export
 * @interface ExceptionResponseEntityErrorsInner
 */
export interface ExceptionResponseEntityErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof ExceptionResponseEntityErrorsInner
     */
    'fieldPath': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExceptionResponseEntityErrorsInner
     */
    'messages': Array<string>;
}
/**
 * 
 * @export
 * @interface FinancialStatementOutcomeReportDataEntity
 */
export interface FinancialStatementOutcomeReportDataEntity {
    /**
     * 
     * @type {string}
     * @memberof FinancialStatementOutcomeReportDataEntity
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FinancialStatementOutcomeReportDataEntity
     */
    'outcome': number;
    /**
     * 
     * @type {number}
     * @memberof FinancialStatementOutcomeReportDataEntity
     */
    'percentage'?: number;
}
/**
 * 
 * @export
 * @interface FinancialStatementOutflowsSubcategoryData
 */
export interface FinancialStatementOutflowsSubcategoryData {
    /**
     * 
     * @type {string}
     * @memberof FinancialStatementOutflowsSubcategoryData
     */
    'subcategoryId': string;
    /**
     * 
     * @type {string}
     * @memberof FinancialStatementOutflowsSubcategoryData
     */
    'subcategoryName': string;
    /**
     * 
     * @type {number}
     * @memberof FinancialStatementOutflowsSubcategoryData
     */
    'outcome': number;
}
/**
 * 
 * @export
 * @interface FinancialStatementOutlfowsCategoryData
 */
export interface FinancialStatementOutlfowsCategoryData {
    /**
     * 
     * @type {string}
     * @memberof FinancialStatementOutlfowsCategoryData
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof FinancialStatementOutlfowsCategoryData
     */
    'categoryName': string;
    /**
     * 
     * @type {number}
     * @memberof FinancialStatementOutlfowsCategoryData
     */
    'outcome': number;
    /**
     * 
     * @type {Array<FinancialStatementOutflowsSubcategoryData>}
     * @memberof FinancialStatementOutlfowsCategoryData
     */
    'subcategories': Array<FinancialStatementOutflowsSubcategoryData>;
}
/**
 * 
 * @export
 * @interface FinancialStatementReport
 */
export interface FinancialStatementReport {
    /**
     * 
     * @type {Array<FinancialStatementReportItemEntity>}
     * @memberof FinancialStatementReport
     */
    'items': Array<FinancialStatementReportItemEntity>;
}
/**
 * 
 * @export
 * @interface FinancialStatementReportItemEntity
 */
export interface FinancialStatementReportItemEntity {
    /**
     * 
     * @type {string}
     * @memberof FinancialStatementReportItemEntity
     */
    'type': string;
    /**
     * 
     * @type {FinancialStatementeEntriesCategoryData}
     * @memberof FinancialStatementReportItemEntity
     */
    'entriesCategoryData'?: FinancialStatementeEntriesCategoryData;
    /**
     * 
     * @type {FinancialStatementOutlfowsCategoryData}
     * @memberof FinancialStatementReportItemEntity
     */
    'outflowsCategoryData'?: FinancialStatementOutlfowsCategoryData;
    /**
     * 
     * @type {FinancialStatementOutcomeReportDataEntity}
     * @memberof FinancialStatementReportItemEntity
     */
    'outcomeData'?: FinancialStatementOutcomeReportDataEntity;
}
/**
 * 
 * @export
 * @interface FinancialStatementeEntriesCategoryData
 */
export interface FinancialStatementeEntriesCategoryData {
    /**
     * 
     * @type {string}
     * @memberof FinancialStatementeEntriesCategoryData
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof FinancialStatementeEntriesCategoryData
     */
    'categoryName': string;
    /**
     * 
     * @type {number}
     * @memberof FinancialStatementeEntriesCategoryData
     */
    'outcome': number;
    /**
     * 
     * @type {Array<FinancialStatementeEntriesSubcategoryData>}
     * @memberof FinancialStatementeEntriesCategoryData
     */
    'subcategories': Array<FinancialStatementeEntriesSubcategoryData>;
}
/**
 * 
 * @export
 * @interface FinancialStatementeEntriesSubcategoryData
 */
export interface FinancialStatementeEntriesSubcategoryData {
    /**
     * 
     * @type {string}
     * @memberof FinancialStatementeEntriesSubcategoryData
     */
    'subcategoryId': string;
    /**
     * 
     * @type {string}
     * @memberof FinancialStatementeEntriesSubcategoryData
     */
    'subcategoryName': string;
    /**
     * 
     * @type {number}
     * @memberof FinancialStatementeEntriesSubcategoryData
     */
    'outcome': number;
}
/**
 * 
 * @export
 * @interface GenerateAndSendEmailVerificationCodeRequestDto
 */
export interface GenerateAndSendEmailVerificationCodeRequestDto {
    /**
     * 
     * @type {string}
     * @memberof GenerateAndSendEmailVerificationCodeRequestDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateAndSendEmailVerificationCodeRequestDto
     */
    'purpose': GenerateAndSendEmailVerificationCodeRequestDtoPurposeEnum;
}

export const GenerateAndSendEmailVerificationCodeRequestDtoPurposeEnum = {
    Up: 'SIGN_UP',
    In: 'SIGN_IN'
} as const;

export type GenerateAndSendEmailVerificationCodeRequestDtoPurposeEnum = typeof GenerateAndSendEmailVerificationCodeRequestDtoPurposeEnum[keyof typeof GenerateAndSendEmailVerificationCodeRequestDtoPurposeEnum];

/**
 * 
 * @export
 * @interface GenerateAndSendPhoneVerificationCodeRequestDto
 */
export interface GenerateAndSendPhoneVerificationCodeRequestDto {
    /**
     * 
     * @type {string}
     * @memberof GenerateAndSendPhoneVerificationCodeRequestDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateAndSendPhoneVerificationCodeRequestDto
     */
    'purpose': GenerateAndSendPhoneVerificationCodeRequestDtoPurposeEnum;
}

export const GenerateAndSendPhoneVerificationCodeRequestDtoPurposeEnum = {
    Up: 'SIGN_UP',
    In: 'SIGN_IN'
} as const;

export type GenerateAndSendPhoneVerificationCodeRequestDtoPurposeEnum = typeof GenerateAndSendPhoneVerificationCodeRequestDtoPurposeEnum[keyof typeof GenerateAndSendPhoneVerificationCodeRequestDtoPurposeEnum];

/**
 * 
 * @export
 * @interface GenerateEmailInUseReportRequestDto
 */
export interface GenerateEmailInUseReportRequestDto {
    /**
     * 
     * @type {string}
     * @memberof GenerateEmailInUseReportRequestDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface GeneratePhoneInUseReportRequestDto
 */
export interface GeneratePhoneInUseReportRequestDto {
    /**
     * 
     * @type {string}
     * @memberof GeneratePhoneInUseReportRequestDto
     */
    'phone': string;
}
/**
 * 
 * @export
 * @interface MeanResultEntity
 */
export interface MeanResultEntity {
    /**
     * 
     * @type {number}
     * @memberof MeanResultEntity
     */
    'amountInCents'?: number;
    /**
     * 
     * @type {Array<MeanResultSubcategoryItemEntity>}
     * @memberof MeanResultEntity
     */
    'subcategories'?: Array<MeanResultSubcategoryItemEntity>;
}
/**
 * 
 * @export
 * @interface MeanResultSubcategoryItemEntity
 */
export interface MeanResultSubcategoryItemEntity {
    /**
     * 
     * @type {string}
     * @memberof MeanResultSubcategoryItemEntity
     */
    'subcategoryId': string;
    /**
     * 
     * @type {string}
     * @memberof MeanResultSubcategoryItemEntity
     */
    'subcategoryName': string;
    /**
     * 
     * @type {number}
     * @memberof MeanResultSubcategoryItemEntity
     */
    'amountInCents'?: number;
}
/**
 * 
 * @export
 * @interface MessageTokenEntity
 */
export interface MessageTokenEntity {
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntity
     */
    'workspaceId': string;
    /**
     * 
     * @type {MessageTokenEntityWorksapce}
     * @memberof MessageTokenEntity
     */
    'worksapce'?: MessageTokenEntityWorksapce | null;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntity
     */
    'userId': string;
    /**
     * 
     * @type {MessageTokenEntityUser}
     * @memberof MessageTokenEntity
     */
    'user'?: MessageTokenEntityUser | null;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntity
     */
    'provider': MessageTokenEntityProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntity
     */
    'platform': MessageTokenEntityPlatformEnum;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntity
     */
    'deviceId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntity
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntity
     */
    'updatedAt': string;
}

export const MessageTokenEntityProviderEnum = {
    FirebaseMessaging: 'FIREBASE_MESSAGING'
} as const;

export type MessageTokenEntityProviderEnum = typeof MessageTokenEntityProviderEnum[keyof typeof MessageTokenEntityProviderEnum];
export const MessageTokenEntityPlatformEnum = {
    Web: 'WEB',
    Android: 'ANDROID',
    Ios: 'IOS'
} as const;

export type MessageTokenEntityPlatformEnum = typeof MessageTokenEntityPlatformEnum[keyof typeof MessageTokenEntityPlatformEnum];

/**
 * 
 * @export
 * @interface MessageTokenEntityUser
 */
export interface MessageTokenEntityUser {
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityUser
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityUser
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityUser
     */
    'passwordHash'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MessageTokenEntityUser
     */
    'isRoot': boolean;
    /**
     * 
     * @type {Array<UserEntityWorkspacesInner>}
     * @memberof MessageTokenEntityUser
     */
    'workspaces'?: Array<UserEntityWorkspacesInner> | null;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityUser
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface MessageTokenEntityWorksapce
 */
export interface MessageTokenEntityWorksapce {
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityWorksapce
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityWorksapce
     */
    'prettyId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityWorksapce
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityWorksapce
     */
    'type': MessageTokenEntityWorksapceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityWorksapce
     */
    'creatorUserId': string;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityWorksapce
     */
    'selectedPersonalCategoryTreeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityWorksapce
     */
    'selectedBusinessCategoryTreeId'?: string | null;
    /**
     * 
     * @type {UserEntityWorkspacesInnerHybridSettings}
     * @memberof MessageTokenEntityWorksapce
     */
    'hybridSettings'?: UserEntityWorkspacesInnerHybridSettings | null;
    /**
     * 
     * @type {UserEntityWorkspacesInnerHybridSettings}
     * @memberof MessageTokenEntityWorksapce
     */
    'businessSettings'?: UserEntityWorkspacesInnerHybridSettings | null;
    /**
     * 
     * @type {UserEntityWorkspacesInnerPersonalSettings}
     * @memberof MessageTokenEntityWorksapce
     */
    'personalSettings'?: UserEntityWorkspacesInnerPersonalSettings | null;
    /**
     * 
     * @type {string}
     * @memberof MessageTokenEntityWorksapce
     */
    'createdAt': string;
}

export const MessageTokenEntityWorksapceTypeEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Hybrid: 'HYBRID'
} as const;

export type MessageTokenEntityWorksapceTypeEnum = typeof MessageTokenEntityWorksapceTypeEnum[keyof typeof MessageTokenEntityWorksapceTypeEnum];

/**
 * 
 * @export
 * @interface PartialUpdateBankTransactionRequestDto
 */
export interface PartialUpdateBankTransactionRequestDto {
    /**
     * 
     * @type {string}
     * @memberof PartialUpdateBankTransactionRequestDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialUpdateBankTransactionRequestDto
     */
    'categoryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialUpdateBankTransactionRequestDto
     */
    'competencyDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PartialUpdateBankTransactionRequestDto
     */
    'ignore'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PartialUpdateBankTransactionRequestDto
     */
    'verify'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PartialUpdateBankTransactionRequestDto
     */
    'tagIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PartialUpdateBankTransactionRequestDto
     */
    'legalNature'?: PartialUpdateBankTransactionRequestDtoLegalNatureEnum;
}

export const PartialUpdateBankTransactionRequestDtoLegalNatureEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Undefined: 'UNDEFINED'
} as const;

export type PartialUpdateBankTransactionRequestDtoLegalNatureEnum = typeof PartialUpdateBankTransactionRequestDtoLegalNatureEnum[keyof typeof PartialUpdateBankTransactionRequestDtoLegalNatureEnum];

/**
 * 
 * @export
 * @interface PartialUpdateProfileRequestDto
 */
export interface PartialUpdateProfileRequestDto {
    /**
     * 
     * @type {string}
     * @memberof PartialUpdateProfileRequestDto
     */
    'fullName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PartialUpdateProfileRequestDto
     */
    'birthDate'?: string | null;
}
/**
 * 
 * @export
 * @interface PartialUpdateWorkspaceRequestDto
 */
export interface PartialUpdateWorkspaceRequestDto {
    /**
     * 
     * @type {string}
     * @memberof PartialUpdateWorkspaceRequestDto
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface PluggyConnectTokenEntity
 */
export interface PluggyConnectTokenEntity {
    /**
     * 
     * @type {string}
     * @memberof PluggyConnectTokenEntity
     */
    'accessToken': string;
}
/**
 * 
 * @export
 * @interface ProfileEntity
 */
export interface ProfileEntity {
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'birthDate': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileEntity
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ProportionResultEntity
 */
export interface ProportionResultEntity {
    /**
     * 
     * @type {number}
     * @memberof ProportionResultEntity
     */
    'ratio'?: number;
}
/**
 * 
 * @export
 * @interface RefreshRequestDto
 */
export interface RefreshRequestDto {
    /**
     * 
     * @type {string}
     * @memberof RefreshRequestDto
     */
    'clientId': string;
}
/**
 * 
 * @export
 * @interface SignInWithEmailRequestDto
 */
export interface SignInWithEmailRequestDto {
    /**
     * 
     * @type {string}
     * @memberof SignInWithEmailRequestDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignInWithEmailRequestDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignInWithEmailRequestDto
     */
    'clientId': string;
}
/**
 * 
 * @export
 * @interface SignUpWithEmailRequestDto
 */
export interface SignUpWithEmailRequestDto {
    /**
     * 
     * @type {string}
     * @memberof SignUpWithEmailRequestDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpWithEmailRequestDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpWithEmailRequestDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpWithEmailRequestDto
     */
    'emailVerificationCode': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpWithEmailRequestDto
     */
    'phoneVerificationCode': string;
}
/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageBeginRequestDto
 */
export interface SyncBankAccountTransactionsPageBeginRequestDto {
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageBeginRequestDto
     */
    'syncItemId': string;
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageBeginRequestDto
     */
    'pageNumber': number;
}
/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageEndRequestDto
 */
export interface SyncBankAccountTransactionsPageEndRequestDto {
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDto
     */
    'syncItemId': string;
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageEndRequestDto
     */
    'pageNumber': number;
    /**
     * 
     * @type {SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage}
     * @memberof SyncBankAccountTransactionsPageEndRequestDto
     */
    'bankProviderTransactionsPage': SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage;
    /**
     * 
     * @type {Array<SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInner>}
     * @memberof SyncBankAccountTransactionsPageEndRequestDto
     */
    'legalNatureAssignRequests': Array<SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInner>;
    /**
     * 
     * @type {Array<SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInner>}
     * @memberof SyncBankAccountTransactionsPageEndRequestDto
     */
    'categoryAssignRequests': Array<SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInner>;
}
/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage
 */
export interface SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage {
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage
     */
    'pageNumber': number;
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage
     */
    'pageSize': number;
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage
     */
    'totalResults': number;
    /**
     * 
     * @type {Array<SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner>}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPage
     */
    'transactions': Array<SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner>;
}
/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
 */
export interface SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner {
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
     */
    'postedDate': string;
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
     */
    'directionNature': SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerDirectionNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
     */
    'status': SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
     */
    'categoryId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
     */
    'categoryName'?: string | null;
    /**
     * 
     * @type {SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
     */
    'paymentData'?: SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData | null;
    /**
     * 
     * @type {SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerCreditCardMetadata}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInner
     */
    'creditCardMetadata'?: SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerCreditCardMetadata | null;
}

export const SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerDirectionNatureEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    Undefined: 'UNDEFINED'
} as const;

export type SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerDirectionNatureEnum = typeof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerDirectionNatureEnum[keyof typeof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerDirectionNatureEnum];
export const SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerStatusEnum = {
    Pending: 'PENDING',
    Posted: 'POSTED'
} as const;

export type SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerStatusEnum = typeof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerStatusEnum[keyof typeof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerStatusEnum];

/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerCreditCardMetadata
 */
export interface SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerCreditCardMetadata {
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerCreditCardMetadata
     */
    'installmentNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerCreditCardMetadata
     */
    'totalInstallments'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerCreditCardMetadata
     */
    'totalAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerCreditCardMetadata
     */
    'payeeMCC'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerCreditCardMetadata
     */
    'cardNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerCreditCardMetadata
     */
    'billId'?: string | null;
}
/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
 */
export interface SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData {
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'payerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'payerBranchNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'payerAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'payerRoutingNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'payerRoutingNumberISPB'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'payerDocumentNumberType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'payerDocumentNumberValue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'reason'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'receiverName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'receiverBranchNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'receiverAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'receiverRoutingNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'receiverRoutingNumberISPB'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'receiverDocumentNumberType'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'receiverDocumentNumberValue'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'paymentMethod'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'referenceNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoBankProviderTransactionsPageTransactionsInnerPaymentData
     */
    'receiverReferenceId'?: string | null;
}
/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInner
 */
export interface SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInner {
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInner
     */
    'bankProviderTransactionId': string;
    /**
     * 
     * @type {SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategory}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInner
     */
    'category': SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategory;
}
/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategory
 */
export interface SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategory {
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategory
     */
    'origin': SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategoryOriginEnum;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategory
     */
    'id'?: string;
    /**
     * 
     * @type {SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategoryPredictionResponse}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategory
     */
    'predictionResponse'?: SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategoryPredictionResponse;
}

export const SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategoryOriginEnum = {
    Undefined: 'UNDEFINED',
    Prediction: 'PREDICTION'
} as const;

export type SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategoryOriginEnum = typeof SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategoryOriginEnum[keyof typeof SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategoryOriginEnum];

/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategoryPredictionResponse
 */
export interface SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategoryPredictionResponse {
    /**
     * 
     * @type {Array<CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCategoryGuessesInner>}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoCategoryAssignRequestsInnerCategoryPredictionResponse
     */
    'sortedCategoryGuesses': Array<CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerCategoryGuessesInner>;
}
/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInner
 */
export interface SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInner {
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInner
     */
    'bankProviderTransactionId': string;
    /**
     * 
     * @type {SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNature}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInner
     */
    'legalNature': SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNature;
}
/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNature
 */
export interface SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNature {
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNature
     */
    'origin': SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNatureOriginEnum;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNature
     */
    'value': SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNatureValueEnum;
    /**
     * 
     * @type {CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInner}
     * @memberof SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNature
     */
    'predictionResponse'?: CreateOrUpdateBankTransactionsInBulkRequestDtoItemsInnerLegalNatureGuessesInner;
}

export const SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNatureOriginEnum = {
    Automatic: 'AUTOMATIC',
    Prediction: 'PREDICTION'
} as const;

export type SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNatureOriginEnum = typeof SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNatureOriginEnum[keyof typeof SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNatureOriginEnum];
export const SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNatureValueEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Undefined: 'UNDEFINED'
} as const;

export type SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNatureValueEnum = typeof SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNatureValueEnum[keyof typeof SyncBankAccountTransactionsPageEndRequestDtoLegalNatureAssignRequestsInnerLegalNatureValueEnum];

/**
 * 
 * @export
 * @interface SyncBankAccountTransactionsRequestDto
 */
export interface SyncBankAccountTransactionsRequestDto {
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsRequestDto
     */
    'accountId': string;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsRequestDto
     */
    'provider': SyncBankAccountTransactionsRequestDtoProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsRequestDto
     */
    'providerAccountId': string;
    /**
     * 
     * @type {string}
     * @memberof SyncBankAccountTransactionsRequestDto
     */
    'providerItemId': string;
}

export const SyncBankAccountTransactionsRequestDtoProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type SyncBankAccountTransactionsRequestDtoProviderEnum = typeof SyncBankAccountTransactionsRequestDtoProviderEnum[keyof typeof SyncBankAccountTransactionsRequestDtoProviderEnum];

/**
 * 
 * @export
 * @interface SyncBankItemRequestDto
 */
export interface SyncBankItemRequestDto {
    /**
     * 
     * @type {string}
     * @memberof SyncBankItemRequestDto
     */
    'providerItemId': string;
    /**
     * 
     * @type {string}
     * @memberof SyncBankItemRequestDto
     */
    'provider': SyncBankItemRequestDtoProviderEnum;
}

export const SyncBankItemRequestDtoProviderEnum = {
    Pluggy: 'PLUGGY',
    Sofia: 'SOFIA'
} as const;

export type SyncBankItemRequestDtoProviderEnum = typeof SyncBankItemRequestDtoProviderEnum[keyof typeof SyncBankItemRequestDtoProviderEnum];

/**
 * 
 * @export
 * @interface UserEntity
 */
export interface UserEntity {
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'passwordHash'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserEntity
     */
    'isRoot': boolean;
    /**
     * 
     * @type {Array<UserEntityWorkspacesInner>}
     * @memberof UserEntity
     */
    'workspaces'?: Array<UserEntityWorkspacesInner> | null;
    /**
     * 
     * @type {string}
     * @memberof UserEntity
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface UserEntityWorkspacesInner
 */
export interface UserEntityWorkspacesInner {
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInner
     */
    'prettyId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInner
     */
    'type': UserEntityWorkspacesInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInner
     */
    'creatorUserId': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInner
     */
    'selectedPersonalCategoryTreeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInner
     */
    'selectedBusinessCategoryTreeId'?: string | null;
    /**
     * 
     * @type {UserEntityWorkspacesInnerHybridSettings}
     * @memberof UserEntityWorkspacesInner
     */
    'hybridSettings'?: UserEntityWorkspacesInnerHybridSettings | null;
    /**
     * 
     * @type {UserEntityWorkspacesInnerHybridSettings}
     * @memberof UserEntityWorkspacesInner
     */
    'businessSettings'?: UserEntityWorkspacesInnerHybridSettings | null;
    /**
     * 
     * @type {UserEntityWorkspacesInnerPersonalSettings}
     * @memberof UserEntityWorkspacesInner
     */
    'personalSettings'?: UserEntityWorkspacesInnerPersonalSettings | null;
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInner
     */
    'createdAt': string;
}

export const UserEntityWorkspacesInnerTypeEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Hybrid: 'HYBRID'
} as const;

export type UserEntityWorkspacesInnerTypeEnum = typeof UserEntityWorkspacesInnerTypeEnum[keyof typeof UserEntityWorkspacesInnerTypeEnum];

/**
 * 
 * @export
 * @interface UserEntityWorkspacesInnerHybridSettings
 */
export interface UserEntityWorkspacesInnerHybridSettings {
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInnerHybridSettings
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInnerHybridSettings
     */
    'businessSegment': UserEntityWorkspacesInnerHybridSettingsBusinessSegmentEnum;
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInnerHybridSettings
     */
    'otherBusinessDescription'?: string | null;
}

export const UserEntityWorkspacesInnerHybridSettingsBusinessSegmentEnum = {
    Attorney: 'ATTORNEY',
    Architect: 'ARCHITECT',
    Consultant: 'CONSULTANT',
    Realtor: 'REALTOR',
    InsuranceBroker: 'INSURANCE_BROKER',
    Dentist: 'DENTIST',
    Physiotherapist: 'PHYSIOTHERAPIST',
    Physician: 'PHYSICIAN',
    Tutor: 'TUTOR',
    Psychologist: 'PSYCHOLOGIST',
    Other: 'OTHER'
} as const;

export type UserEntityWorkspacesInnerHybridSettingsBusinessSegmentEnum = typeof UserEntityWorkspacesInnerHybridSettingsBusinessSegmentEnum[keyof typeof UserEntityWorkspacesInnerHybridSettingsBusinessSegmentEnum];

/**
 * 
 * @export
 * @interface UserEntityWorkspacesInnerPersonalSettings
 */
export interface UserEntityWorkspacesInnerPersonalSettings {
    /**
     * 
     * @type {string}
     * @memberof UserEntityWorkspacesInnerPersonalSettings
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UserRelatedWorkspaceEntity
 */
export interface UserRelatedWorkspaceEntity {
    /**
     * 
     * @type {UserEntityWorkspacesInner}
     * @memberof UserRelatedWorkspaceEntity
     */
    'workspace': UserEntityWorkspacesInner;
    /**
     * 
     * @type {string}
     * @memberof UserRelatedWorkspaceEntity
     */
    'relationType': UserRelatedWorkspaceEntityRelationTypeEnum;
}

export const UserRelatedWorkspaceEntityRelationTypeEnum = {
    Approved: 'APPROVED',
    WaitingApproval: 'WAITING_APPROVAL'
} as const;

export type UserRelatedWorkspaceEntityRelationTypeEnum = typeof UserRelatedWorkspaceEntityRelationTypeEnum[keyof typeof UserRelatedWorkspaceEntityRelationTypeEnum];

/**
 * 
 * @export
 * @interface VerifyEmailVerificationCodeRequestDto
 */
export interface VerifyEmailVerificationCodeRequestDto {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailVerificationCodeRequestDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailVerificationCodeRequestDto
     */
    'purpose': VerifyEmailVerificationCodeRequestDtoPurposeEnum;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailVerificationCodeRequestDto
     */
    'code': string;
}

export const VerifyEmailVerificationCodeRequestDtoPurposeEnum = {
    Up: 'SIGN_UP',
    In: 'SIGN_IN'
} as const;

export type VerifyEmailVerificationCodeRequestDtoPurposeEnum = typeof VerifyEmailVerificationCodeRequestDtoPurposeEnum[keyof typeof VerifyEmailVerificationCodeRequestDtoPurposeEnum];

/**
 * 
 * @export
 * @interface VerifyPhoneVerificationCodeRequestDto
 */
export interface VerifyPhoneVerificationCodeRequestDto {
    /**
     * 
     * @type {string}
     * @memberof VerifyPhoneVerificationCodeRequestDto
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyPhoneVerificationCodeRequestDto
     */
    'purpose': VerifyPhoneVerificationCodeRequestDtoPurposeEnum;
    /**
     * 
     * @type {string}
     * @memberof VerifyPhoneVerificationCodeRequestDto
     */
    'code': string;
}

export const VerifyPhoneVerificationCodeRequestDtoPurposeEnum = {
    Up: 'SIGN_UP',
    In: 'SIGN_IN'
} as const;

export type VerifyPhoneVerificationCodeRequestDtoPurposeEnum = typeof VerifyPhoneVerificationCodeRequestDtoPurposeEnum[keyof typeof VerifyPhoneVerificationCodeRequestDtoPurposeEnum];

/**
 * 
 * @export
 * @interface WorkspaceEntity
 */
export interface WorkspaceEntity {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'prettyId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'type': WorkspaceEntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'creatorUserId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'selectedPersonalCategoryTreeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'selectedBusinessCategoryTreeId'?: string | null;
    /**
     * 
     * @type {UserEntityWorkspacesInnerHybridSettings}
     * @memberof WorkspaceEntity
     */
    'hybridSettings'?: UserEntityWorkspacesInnerHybridSettings | null;
    /**
     * 
     * @type {UserEntityWorkspacesInnerHybridSettings}
     * @memberof WorkspaceEntity
     */
    'businessSettings'?: UserEntityWorkspacesInnerHybridSettings | null;
    /**
     * 
     * @type {UserEntityWorkspacesInnerPersonalSettings}
     * @memberof WorkspaceEntity
     */
    'personalSettings'?: UserEntityWorkspacesInnerPersonalSettings | null;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceEntity
     */
    'createdAt': string;
}

export const WorkspaceEntityTypeEnum = {
    Personal: 'PERSONAL',
    Business: 'BUSINESS',
    Hybrid: 'HYBRID'
} as const;

export type WorkspaceEntityTypeEnum = typeof WorkspaceEntityTypeEnum[keyof typeof WorkspaceEntityTypeEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GenerateAndSendEmailVerificationCodeRequestDto} generateAndSendEmailVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGenerateAndSendEmailVerificationCode: async (generateAndSendEmailVerificationCodeRequestDto: GenerateAndSendEmailVerificationCodeRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateAndSendEmailVerificationCodeRequestDto' is not null or undefined
            assertParamExists('authControllerGenerateAndSendEmailVerificationCode', 'generateAndSendEmailVerificationCodeRequestDto', generateAndSendEmailVerificationCodeRequestDto)
            const localVarPath = `/iam/auth/email-verification-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateAndSendEmailVerificationCodeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GenerateAndSendPhoneVerificationCodeRequestDto} generateAndSendPhoneVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGenerateAndSendPhoneVerificationCode: async (generateAndSendPhoneVerificationCodeRequestDto: GenerateAndSendPhoneVerificationCodeRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateAndSendPhoneVerificationCodeRequestDto' is not null or undefined
            assertParamExists('authControllerGenerateAndSendPhoneVerificationCode', 'generateAndSendPhoneVerificationCodeRequestDto', generateAndSendPhoneVerificationCodeRequestDto)
            const localVarPath = `/iam/auth/phone-verification-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateAndSendPhoneVerificationCodeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GenerateEmailInUseReportRequestDto} generateEmailInUseReportRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGenerateEmailInUseReport: async (generateEmailInUseReportRequestDto: GenerateEmailInUseReportRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateEmailInUseReportRequestDto' is not null or undefined
            assertParamExists('authControllerGenerateEmailInUseReport', 'generateEmailInUseReportRequestDto', generateEmailInUseReportRequestDto)
            const localVarPath = `/iam/auth/email-in-use`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateEmailInUseReportRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GeneratePhoneInUseReportRequestDto} generatePhoneInUseReportRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGeneratePhoneInUseReport: async (generatePhoneInUseReportRequestDto: GeneratePhoneInUseReportRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generatePhoneInUseReportRequestDto' is not null or undefined
            assertParamExists('authControllerGeneratePhoneInUseReport', 'generatePhoneInUseReportRequestDto', generatePhoneInUseReportRequestDto)
            const localVarPath = `/iam/auth/phone-in-use`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generatePhoneInUseReportRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshRequestDto} refreshRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh: async (refreshRequestDto: RefreshRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshRequestDto' is not null or undefined
            assertParamExists('authControllerRefresh', 'refreshRequestDto', refreshRequestDto)
            const localVarPath = `/iam/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInWithEmailRequestDto} signInWithEmailRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignInWithEmail: async (signInWithEmailRequestDto: SignInWithEmailRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInWithEmailRequestDto' is not null or undefined
            assertParamExists('authControllerSignInWithEmail', 'signInWithEmailRequestDto', signInWithEmailRequestDto)
            const localVarPath = `/iam/auth/sign-in/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInWithEmailRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpWithEmailRequestDto} signUpWithEmailRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUpWithEmail: async (signUpWithEmailRequestDto: SignUpWithEmailRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpWithEmailRequestDto' is not null or undefined
            assertParamExists('authControllerSignUpWithEmail', 'signUpWithEmailRequestDto', signUpWithEmailRequestDto)
            const localVarPath = `/iam/auth/sign-up/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpWithEmailRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VerifyEmailVerificationCodeRequestDto} verifyEmailVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmailVerificationCode: async (verifyEmailVerificationCodeRequestDto: VerifyEmailVerificationCodeRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailVerificationCodeRequestDto' is not null or undefined
            assertParamExists('authControllerVerifyEmailVerificationCode', 'verifyEmailVerificationCodeRequestDto', verifyEmailVerificationCodeRequestDto)
            const localVarPath = `/iam/auth/email-verification-code/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailVerificationCodeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VerifyPhoneVerificationCodeRequestDto} verifyPhoneVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyPhoneVerificationCode: async (verifyPhoneVerificationCodeRequestDto: VerifyPhoneVerificationCodeRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyPhoneVerificationCodeRequestDto' is not null or undefined
            assertParamExists('authControllerVerifyPhoneVerificationCode', 'verifyPhoneVerificationCodeRequestDto', verifyPhoneVerificationCodeRequestDto)
            const localVarPath = `/iam/auth/phone-verification-code/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyPhoneVerificationCodeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {GenerateAndSendEmailVerificationCodeRequestDto} generateAndSendEmailVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGenerateAndSendEmailVerificationCode(generateAndSendEmailVerificationCodeRequestDto: GenerateAndSendEmailVerificationCodeRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGenerateAndSendEmailVerificationCode(generateAndSendEmailVerificationCodeRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGenerateAndSendEmailVerificationCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GenerateAndSendPhoneVerificationCodeRequestDto} generateAndSendPhoneVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGenerateAndSendPhoneVerificationCode(generateAndSendPhoneVerificationCodeRequestDto: GenerateAndSendPhoneVerificationCodeRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGenerateAndSendPhoneVerificationCode(generateAndSendPhoneVerificationCodeRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGenerateAndSendPhoneVerificationCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GenerateEmailInUseReportRequestDto} generateEmailInUseReportRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGenerateEmailInUseReport(generateEmailInUseReportRequestDto: GenerateEmailInUseReportRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailInUseReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGenerateEmailInUseReport(generateEmailInUseReportRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGenerateEmailInUseReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GeneratePhoneInUseReportRequestDto} generatePhoneInUseReportRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGeneratePhoneInUseReport(generatePhoneInUseReportRequestDto: GeneratePhoneInUseReportRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailInUseReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGeneratePhoneInUseReport(generatePhoneInUseReportRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGeneratePhoneInUseReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshRequestDto} refreshRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefresh(refreshRequestDto: RefreshRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefresh(refreshRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignInWithEmailRequestDto} signInWithEmailRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignInWithEmail(signInWithEmailRequestDto: SignInWithEmailRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignInWithEmail(signInWithEmailRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignInWithEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignUpWithEmailRequestDto} signUpWithEmailRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignUpWithEmail(signUpWithEmailRequestDto: SignUpWithEmailRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignUpWithEmail(signUpWithEmailRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerSignUpWithEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VerifyEmailVerificationCodeRequestDto} verifyEmailVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyEmailVerificationCode(verifyEmailVerificationCodeRequestDto: VerifyEmailVerificationCodeRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyEmailVerificationCode(verifyEmailVerificationCodeRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerVerifyEmailVerificationCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VerifyPhoneVerificationCodeRequestDto} verifyPhoneVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerifyPhoneVerificationCode(verifyPhoneVerificationCodeRequestDto: VerifyPhoneVerificationCodeRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerifyPhoneVerificationCode(verifyPhoneVerificationCodeRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerVerifyPhoneVerificationCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {GenerateAndSendEmailVerificationCodeRequestDto} generateAndSendEmailVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGenerateAndSendEmailVerificationCode(generateAndSendEmailVerificationCodeRequestDto: GenerateAndSendEmailVerificationCodeRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerGenerateAndSendEmailVerificationCode(generateAndSendEmailVerificationCodeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GenerateAndSendPhoneVerificationCodeRequestDto} generateAndSendPhoneVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGenerateAndSendPhoneVerificationCode(generateAndSendPhoneVerificationCodeRequestDto: GenerateAndSendPhoneVerificationCodeRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerGenerateAndSendPhoneVerificationCode(generateAndSendPhoneVerificationCodeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GenerateEmailInUseReportRequestDto} generateEmailInUseReportRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGenerateEmailInUseReport(generateEmailInUseReportRequestDto: GenerateEmailInUseReportRequestDto, options?: any): AxiosPromise<EmailInUseReportEntity> {
            return localVarFp.authControllerGenerateEmailInUseReport(generateEmailInUseReportRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GeneratePhoneInUseReportRequestDto} generatePhoneInUseReportRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGeneratePhoneInUseReport(generatePhoneInUseReportRequestDto: GeneratePhoneInUseReportRequestDto, options?: any): AxiosPromise<EmailInUseReportEntity> {
            return localVarFp.authControllerGeneratePhoneInUseReport(generatePhoneInUseReportRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetMe(options?: any): AxiosPromise<UserEntity> {
            return localVarFp.authControllerGetMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshRequestDto} refreshRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh(refreshRequestDto: RefreshRequestDto, options?: any): AxiosPromise<CredentialsEntity> {
            return localVarFp.authControllerRefresh(refreshRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInWithEmailRequestDto} signInWithEmailRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignInWithEmail(signInWithEmailRequestDto: SignInWithEmailRequestDto, options?: any): AxiosPromise<CredentialsEntity> {
            return localVarFp.authControllerSignInWithEmail(signInWithEmailRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpWithEmailRequestDto} signUpWithEmailRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUpWithEmail(signUpWithEmailRequestDto: SignUpWithEmailRequestDto, options?: any): AxiosPromise<UserEntity> {
            return localVarFp.authControllerSignUpWithEmail(signUpWithEmailRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VerifyEmailVerificationCodeRequestDto} verifyEmailVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyEmailVerificationCode(verifyEmailVerificationCodeRequestDto: VerifyEmailVerificationCodeRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerVerifyEmailVerificationCode(verifyEmailVerificationCodeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VerifyPhoneVerificationCodeRequestDto} verifyPhoneVerificationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerifyPhoneVerificationCode(verifyPhoneVerificationCodeRequestDto: VerifyPhoneVerificationCodeRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerVerifyPhoneVerificationCode(verifyPhoneVerificationCodeRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {GenerateAndSendEmailVerificationCodeRequestDto} generateAndSendEmailVerificationCodeRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGenerateAndSendEmailVerificationCode(generateAndSendEmailVerificationCodeRequestDto: GenerateAndSendEmailVerificationCodeRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGenerateAndSendEmailVerificationCode(generateAndSendEmailVerificationCodeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenerateAndSendPhoneVerificationCodeRequestDto} generateAndSendPhoneVerificationCodeRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGenerateAndSendPhoneVerificationCode(generateAndSendPhoneVerificationCodeRequestDto: GenerateAndSendPhoneVerificationCodeRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGenerateAndSendPhoneVerificationCode(generateAndSendPhoneVerificationCodeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenerateEmailInUseReportRequestDto} generateEmailInUseReportRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGenerateEmailInUseReport(generateEmailInUseReportRequestDto: GenerateEmailInUseReportRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGenerateEmailInUseReport(generateEmailInUseReportRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GeneratePhoneInUseReportRequestDto} generatePhoneInUseReportRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGeneratePhoneInUseReport(generatePhoneInUseReportRequestDto: GeneratePhoneInUseReportRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGeneratePhoneInUseReport(generatePhoneInUseReportRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetMe(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshRequestDto} refreshRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerRefresh(refreshRequestDto: RefreshRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerRefresh(refreshRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInWithEmailRequestDto} signInWithEmailRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignInWithEmail(signInWithEmailRequestDto: SignInWithEmailRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignInWithEmail(signInWithEmailRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpWithEmailRequestDto} signUpWithEmailRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignUpWithEmail(signUpWithEmailRequestDto: SignUpWithEmailRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignUpWithEmail(signUpWithEmailRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VerifyEmailVerificationCodeRequestDto} verifyEmailVerificationCodeRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerVerifyEmailVerificationCode(verifyEmailVerificationCodeRequestDto: VerifyEmailVerificationCodeRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerVerifyEmailVerificationCode(verifyEmailVerificationCodeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VerifyPhoneVerificationCodeRequestDto} verifyPhoneVerificationCodeRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerVerifyPhoneVerificationCode(verifyPhoneVerificationCodeRequestDto: VerifyPhoneVerificationCodeRequestDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerVerifyPhoneVerificationCode(verifyPhoneVerificationCodeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankAccountsApi - axios parameter creator
 * @export
 */
export const BankAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerActivate: async (bankAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankAccountId' is not null or undefined
            assertParamExists('bankAccountsControllerActivate', 'bankAccountId', bankAccountId)
            const localVarPath = `/bank/accounts/{bankAccountId}/activate`
                .replace(`{${"bankAccountId"}}`, encodeURIComponent(String(bankAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateOrUpdateBankAccountRequestDto} createOrUpdateBankAccountRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerCreateOrUpdate: async (createOrUpdateBankAccountRequestDto: CreateOrUpdateBankAccountRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrUpdateBankAccountRequestDto' is not null or undefined
            assertParamExists('bankAccountsControllerCreateOrUpdate', 'createOrUpdateBankAccountRequestDto', createOrUpdateBankAccountRequestDto)
            const localVarPath = `/bank/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateBankAccountRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerCreateWorkspaceBalanceReport: async (workspaceId: string, enabled?: boolean, types?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankAccountsControllerCreateWorkspaceBalanceReport', 'workspaceId', workspaceId)
            const localVarPath = `/bank/workspaces/{workspaceId}/accounts/balance-report`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerDisable: async (bankAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankAccountId' is not null or undefined
            assertParamExists('bankAccountsControllerDisable', 'bankAccountId', bankAccountId)
            const localVarPath = `/bank/accounts/{bankAccountId}/disable`
                .replace(`{${"bankAccountId"}}`, encodeURIComponent(String(bankAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerGetById: async (bankAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankAccountId' is not null or undefined
            assertParamExists('bankAccountsControllerGetById', 'bankAccountId', bankAccountId)
            const localVarPath = `/bank/accounts/{bankAccountId}`
                .replace(`{${"bankAccountId"}}`, encodeURIComponent(String(bankAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerListByBankConnectionId: async (bankConnectionId: string, enabled?: boolean, types?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankConnectionId' is not null or undefined
            assertParamExists('bankAccountsControllerListByBankConnectionId', 'bankConnectionId', bankConnectionId)
            const localVarPath = `/bank/connections/{bankConnectionId}/accounts`
                .replace(`{${"bankConnectionId"}}`, encodeURIComponent(String(bankConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerListByWorkspaceId: async (workspaceId: string, enabled?: boolean, types?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankAccountsControllerListByWorkspaceId', 'workspaceId', workspaceId)
            const localVarPath = `/bank/workspaces/{workspaceId}/accounts`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankAccountsApi - functional programming interface
 * @export
 */
export const BankAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerActivate(bankAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerActivate(bankAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerActivate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateOrUpdateBankAccountRequestDto} createOrUpdateBankAccountRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerCreateOrUpdate(createOrUpdateBankAccountRequestDto: CreateOrUpdateBankAccountRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerCreateOrUpdate(createOrUpdateBankAccountRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerCreateOrUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerCreateWorkspaceBalanceReport(workspaceId: string, enabled?: boolean, types?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountsBalanceReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerCreateWorkspaceBalanceReport(workspaceId, enabled, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerCreateWorkspaceBalanceReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerDisable(bankAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerDisable(bankAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerDisable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerGetById(bankAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerGetById(bankAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerListByBankConnectionId(bankConnectionId: string, enabled?: boolean, types?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankAccountEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerListByBankConnectionId(bankConnectionId, enabled, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerListByBankConnectionId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankAccountsControllerListByWorkspaceId(workspaceId: string, enabled?: boolean, types?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankAccountEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsControllerListByWorkspaceId(workspaceId, enabled, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankAccountsApi.bankAccountsControllerListByWorkspaceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankAccountsApi - factory interface
 * @export
 */
export const BankAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankAccountsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerActivate(bankAccountId: string, options?: any): AxiosPromise<BankAccountEntity> {
            return localVarFp.bankAccountsControllerActivate(bankAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateOrUpdateBankAccountRequestDto} createOrUpdateBankAccountRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerCreateOrUpdate(createOrUpdateBankAccountRequestDto: CreateOrUpdateBankAccountRequestDto, options?: any): AxiosPromise<BankAccountEntity> {
            return localVarFp.bankAccountsControllerCreateOrUpdate(createOrUpdateBankAccountRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerCreateWorkspaceBalanceReport(workspaceId: string, enabled?: boolean, types?: string, options?: any): AxiosPromise<BankAccountsBalanceReportEntity> {
            return localVarFp.bankAccountsControllerCreateWorkspaceBalanceReport(workspaceId, enabled, types, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerDisable(bankAccountId: string, options?: any): AxiosPromise<BankAccountEntity> {
            return localVarFp.bankAccountsControllerDisable(bankAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerGetById(bankAccountId: string, options?: any): AxiosPromise<BankAccountEntity> {
            return localVarFp.bankAccountsControllerGetById(bankAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerListByBankConnectionId(bankConnectionId: string, enabled?: boolean, types?: string, options?: any): AxiosPromise<Array<BankAccountEntity>> {
            return localVarFp.bankAccountsControllerListByBankConnectionId(bankConnectionId, enabled, types, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {string} [types] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankAccountsControllerListByWorkspaceId(workspaceId: string, enabled?: boolean, types?: string, options?: any): AxiosPromise<Array<BankAccountEntity>> {
            return localVarFp.bankAccountsControllerListByWorkspaceId(workspaceId, enabled, types, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankAccountsApi - object-oriented interface
 * @export
 * @class BankAccountsApi
 * @extends {BaseAPI}
 */
export class BankAccountsApi extends BaseAPI {
    /**
     * 
     * @param {string} bankAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerActivate(bankAccountId: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerActivate(bankAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateOrUpdateBankAccountRequestDto} createOrUpdateBankAccountRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerCreateOrUpdate(createOrUpdateBankAccountRequestDto: CreateOrUpdateBankAccountRequestDto, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerCreateOrUpdate(createOrUpdateBankAccountRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {boolean} [enabled] 
     * @param {string} [types] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerCreateWorkspaceBalanceReport(workspaceId: string, enabled?: boolean, types?: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerCreateWorkspaceBalanceReport(workspaceId, enabled, types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerDisable(bankAccountId: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerDisable(bankAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerGetById(bankAccountId: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerGetById(bankAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankConnectionId 
     * @param {boolean} [enabled] 
     * @param {string} [types] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerListByBankConnectionId(bankConnectionId: string, enabled?: boolean, types?: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerListByBankConnectionId(bankConnectionId, enabled, types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {boolean} [enabled] 
     * @param {string} [types] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankAccountsApi
     */
    public bankAccountsControllerListByWorkspaceId(workspaceId: string, enabled?: boolean, types?: string, options?: RawAxiosRequestConfig) {
        return BankAccountsApiFp(this.configuration).bankAccountsControllerListByWorkspaceId(workspaceId, enabled, types, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankConnectionsApi - axios parameter creator
 * @export
 */
export const BankConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerActivate: async (bankConnectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankConnectionId' is not null or undefined
            assertParamExists('bankConnectionsControllerActivate', 'bankConnectionId', bankConnectionId)
            const localVarPath = `/bank/connections/{bankConnectionId}/activate`
                .replace(`{${"bankConnectionId"}}`, encodeURIComponent(String(bankConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateBankConnectionRequestDto} createOrUpdateBankConnectionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerCreateOrUpdate: async (workspaceId: string, createOrUpdateBankConnectionRequestDto: CreateOrUpdateBankConnectionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankConnectionsControllerCreateOrUpdate', 'workspaceId', workspaceId)
            // verify required parameter 'createOrUpdateBankConnectionRequestDto' is not null or undefined
            assertParamExists('bankConnectionsControllerCreateOrUpdate', 'createOrUpdateBankConnectionRequestDto', createOrUpdateBankConnectionRequestDto)
            const localVarPath = `/bank/workspaces/{workspaceId}/connections`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateBankConnectionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerDisable: async (bankConnectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankConnectionId' is not null or undefined
            assertParamExists('bankConnectionsControllerDisable', 'bankConnectionId', bankConnectionId)
            const localVarPath = `/bank/connections/{bankConnectionId}/disable`
                .replace(`{${"bankConnectionId"}}`, encodeURIComponent(String(bankConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerGetById: async (bankConnectionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankConnectionId' is not null or undefined
            assertParamExists('bankConnectionsControllerGetById', 'bankConnectionId', bankConnectionId)
            const localVarPath = `/bank/connections/{bankConnectionId}`
                .replace(`{${"bankConnectionId"}}`, encodeURIComponent(String(bankConnectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerList: async (workspaceId: string, enabled?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankConnectionsControllerList', 'workspaceId', workspaceId)
            const localVarPath = `/bank/workspaces/{workspaceId}/connections`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankConnectionsApi - functional programming interface
 * @export
 */
export const BankConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankConnectionsControllerActivate(bankConnectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankConnectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankConnectionsControllerActivate(bankConnectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankConnectionsApi.bankConnectionsControllerActivate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateBankConnectionRequestDto} createOrUpdateBankConnectionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankConnectionsControllerCreateOrUpdate(workspaceId: string, createOrUpdateBankConnectionRequestDto: CreateOrUpdateBankConnectionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankConnectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankConnectionsControllerCreateOrUpdate(workspaceId, createOrUpdateBankConnectionRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankConnectionsApi.bankConnectionsControllerCreateOrUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankConnectionsControllerDisable(bankConnectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankConnectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankConnectionsControllerDisable(bankConnectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankConnectionsApi.bankConnectionsControllerDisable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankConnectionsControllerGetById(bankConnectionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankConnectionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankConnectionsControllerGetById(bankConnectionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankConnectionsApi.bankConnectionsControllerGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankConnectionsControllerList(workspaceId: string, enabled?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankConnectionEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankConnectionsControllerList(workspaceId, enabled, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankConnectionsApi.bankConnectionsControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankConnectionsApi - factory interface
 * @export
 */
export const BankConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerActivate(bankConnectionId: string, options?: any): AxiosPromise<BankConnectionEntity> {
            return localVarFp.bankConnectionsControllerActivate(bankConnectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateBankConnectionRequestDto} createOrUpdateBankConnectionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerCreateOrUpdate(workspaceId: string, createOrUpdateBankConnectionRequestDto: CreateOrUpdateBankConnectionRequestDto, options?: any): AxiosPromise<BankConnectionEntity> {
            return localVarFp.bankConnectionsControllerCreateOrUpdate(workspaceId, createOrUpdateBankConnectionRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerDisable(bankConnectionId: string, options?: any): AxiosPromise<BankConnectionEntity> {
            return localVarFp.bankConnectionsControllerDisable(bankConnectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankConnectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerGetById(bankConnectionId: string, options?: any): AxiosPromise<BankConnectionEntity> {
            return localVarFp.bankConnectionsControllerGetById(bankConnectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankConnectionsControllerList(workspaceId: string, enabled?: boolean, options?: any): AxiosPromise<Array<BankConnectionEntity>> {
            return localVarFp.bankConnectionsControllerList(workspaceId, enabled, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankConnectionsApi - object-oriented interface
 * @export
 * @class BankConnectionsApi
 * @extends {BaseAPI}
 */
export class BankConnectionsApi extends BaseAPI {
    /**
     * 
     * @param {string} bankConnectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankConnectionsApi
     */
    public bankConnectionsControllerActivate(bankConnectionId: string, options?: RawAxiosRequestConfig) {
        return BankConnectionsApiFp(this.configuration).bankConnectionsControllerActivate(bankConnectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {CreateOrUpdateBankConnectionRequestDto} createOrUpdateBankConnectionRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankConnectionsApi
     */
    public bankConnectionsControllerCreateOrUpdate(workspaceId: string, createOrUpdateBankConnectionRequestDto: CreateOrUpdateBankConnectionRequestDto, options?: RawAxiosRequestConfig) {
        return BankConnectionsApiFp(this.configuration).bankConnectionsControllerCreateOrUpdate(workspaceId, createOrUpdateBankConnectionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankConnectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankConnectionsApi
     */
    public bankConnectionsControllerDisable(bankConnectionId: string, options?: RawAxiosRequestConfig) {
        return BankConnectionsApiFp(this.configuration).bankConnectionsControllerDisable(bankConnectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankConnectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankConnectionsApi
     */
    public bankConnectionsControllerGetById(bankConnectionId: string, options?: RawAxiosRequestConfig) {
        return BankConnectionsApiFp(this.configuration).bankConnectionsControllerGetById(bankConnectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {boolean} [enabled] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankConnectionsApi
     */
    public bankConnectionsControllerList(workspaceId: string, enabled?: boolean, options?: RawAxiosRequestConfig) {
        return BankConnectionsApiFp(this.configuration).bankConnectionsControllerList(workspaceId, enabled, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankSyncApi - axios parameter creator
 * @export
 */
export const BankSyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SyncBankAccountTransactionsRequestDto} syncBankAccountTransactionsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankSyncControllerSyncAccountTransactions: async (syncBankAccountTransactionsRequestDto: SyncBankAccountTransactionsRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncBankAccountTransactionsRequestDto' is not null or undefined
            assertParamExists('bankSyncControllerSyncAccountTransactions', 'syncBankAccountTransactionsRequestDto', syncBankAccountTransactionsRequestDto)
            const localVarPath = `/bank/sync/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncBankAccountTransactionsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SyncBankItemRequestDto} syncBankItemRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankSyncControllerSyncItem: async (syncBankItemRequestDto: SyncBankItemRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncBankItemRequestDto' is not null or undefined
            assertParamExists('bankSyncControllerSyncItem', 'syncBankItemRequestDto', syncBankItemRequestDto)
            const localVarPath = `/bank/sync/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncBankItemRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SyncBankAccountTransactionsPageBeginRequestDto} syncBankAccountTransactionsPageBeginRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankSyncControllerSyncTransactionsPageBegin: async (syncBankAccountTransactionsPageBeginRequestDto: SyncBankAccountTransactionsPageBeginRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncBankAccountTransactionsPageBeginRequestDto' is not null or undefined
            assertParamExists('bankSyncControllerSyncTransactionsPageBegin', 'syncBankAccountTransactionsPageBeginRequestDto', syncBankAccountTransactionsPageBeginRequestDto)
            const localVarPath = `/bank/sync/transactions/page/begin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncBankAccountTransactionsPageBeginRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SyncBankAccountTransactionsPageEndRequestDto} syncBankAccountTransactionsPageEndRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankSyncControllerSyncTransactionsPageEnd: async (syncBankAccountTransactionsPageEndRequestDto: SyncBankAccountTransactionsPageEndRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncBankAccountTransactionsPageEndRequestDto' is not null or undefined
            assertParamExists('bankSyncControllerSyncTransactionsPageEnd', 'syncBankAccountTransactionsPageEndRequestDto', syncBankAccountTransactionsPageEndRequestDto)
            const localVarPath = `/bank/sync/transactions/page/end`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncBankAccountTransactionsPageEndRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankSyncApi - functional programming interface
 * @export
 */
export const BankSyncApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankSyncApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SyncBankAccountTransactionsRequestDto} syncBankAccountTransactionsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankSyncControllerSyncAccountTransactions(syncBankAccountTransactionsRequestDto: SyncBankAccountTransactionsRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankSyncControllerSyncAccountTransactions(syncBankAccountTransactionsRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankSyncApi.bankSyncControllerSyncAccountTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SyncBankItemRequestDto} syncBankItemRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankSyncControllerSyncItem(syncBankItemRequestDto: SyncBankItemRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankSyncControllerSyncItem(syncBankItemRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankSyncApi.bankSyncControllerSyncItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SyncBankAccountTransactionsPageBeginRequestDto} syncBankAccountTransactionsPageBeginRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankSyncControllerSyncTransactionsPageBegin(syncBankAccountTransactionsPageBeginRequestDto: SyncBankAccountTransactionsPageBeginRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankSyncControllerSyncTransactionsPageBegin(syncBankAccountTransactionsPageBeginRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankSyncApi.bankSyncControllerSyncTransactionsPageBegin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SyncBankAccountTransactionsPageEndRequestDto} syncBankAccountTransactionsPageEndRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankSyncControllerSyncTransactionsPageEnd(syncBankAccountTransactionsPageEndRequestDto: SyncBankAccountTransactionsPageEndRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankSyncControllerSyncTransactionsPageEnd(syncBankAccountTransactionsPageEndRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankSyncApi.bankSyncControllerSyncTransactionsPageEnd']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankSyncApi - factory interface
 * @export
 */
export const BankSyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankSyncApiFp(configuration)
    return {
        /**
         * 
         * @param {SyncBankAccountTransactionsRequestDto} syncBankAccountTransactionsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankSyncControllerSyncAccountTransactions(syncBankAccountTransactionsRequestDto: SyncBankAccountTransactionsRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.bankSyncControllerSyncAccountTransactions(syncBankAccountTransactionsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SyncBankItemRequestDto} syncBankItemRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankSyncControllerSyncItem(syncBankItemRequestDto: SyncBankItemRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.bankSyncControllerSyncItem(syncBankItemRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SyncBankAccountTransactionsPageBeginRequestDto} syncBankAccountTransactionsPageBeginRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankSyncControllerSyncTransactionsPageBegin(syncBankAccountTransactionsPageBeginRequestDto: SyncBankAccountTransactionsPageBeginRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.bankSyncControllerSyncTransactionsPageBegin(syncBankAccountTransactionsPageBeginRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SyncBankAccountTransactionsPageEndRequestDto} syncBankAccountTransactionsPageEndRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankSyncControllerSyncTransactionsPageEnd(syncBankAccountTransactionsPageEndRequestDto: SyncBankAccountTransactionsPageEndRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.bankSyncControllerSyncTransactionsPageEnd(syncBankAccountTransactionsPageEndRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankSyncApi - object-oriented interface
 * @export
 * @class BankSyncApi
 * @extends {BaseAPI}
 */
export class BankSyncApi extends BaseAPI {
    /**
     * 
     * @param {SyncBankAccountTransactionsRequestDto} syncBankAccountTransactionsRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankSyncApi
     */
    public bankSyncControllerSyncAccountTransactions(syncBankAccountTransactionsRequestDto: SyncBankAccountTransactionsRequestDto, options?: RawAxiosRequestConfig) {
        return BankSyncApiFp(this.configuration).bankSyncControllerSyncAccountTransactions(syncBankAccountTransactionsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncBankItemRequestDto} syncBankItemRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankSyncApi
     */
    public bankSyncControllerSyncItem(syncBankItemRequestDto: SyncBankItemRequestDto, options?: RawAxiosRequestConfig) {
        return BankSyncApiFp(this.configuration).bankSyncControllerSyncItem(syncBankItemRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncBankAccountTransactionsPageBeginRequestDto} syncBankAccountTransactionsPageBeginRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankSyncApi
     */
    public bankSyncControllerSyncTransactionsPageBegin(syncBankAccountTransactionsPageBeginRequestDto: SyncBankAccountTransactionsPageBeginRequestDto, options?: RawAxiosRequestConfig) {
        return BankSyncApiFp(this.configuration).bankSyncControllerSyncTransactionsPageBegin(syncBankAccountTransactionsPageBeginRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncBankAccountTransactionsPageEndRequestDto} syncBankAccountTransactionsPageEndRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankSyncApi
     */
    public bankSyncControllerSyncTransactionsPageEnd(syncBankAccountTransactionsPageEndRequestDto: SyncBankAccountTransactionsPageEndRequestDto, options?: RawAxiosRequestConfig) {
        return BankSyncApiFp(this.configuration).bankSyncControllerSyncTransactionsPageEnd(syncBankAccountTransactionsPageEndRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankTransactionCategoriesApi - axios parameter creator
 * @export
 */
export const BankTransactionCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [onlyLeafs] 
         * @param {string} [directionNatures] 
         * @param {string} [legalNatures] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionCategoriesControllerList: async (workspaceId: string, onlyLeafs?: boolean, directionNatures?: string, legalNatures?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionCategoriesControllerList', 'workspaceId', workspaceId)
            const localVarPath = `/bank/workspaces/{workspaceId}/transaction-categories`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (onlyLeafs !== undefined) {
                localVarQueryParameter['onlyLeafs'] = onlyLeafs;
            }

            if (directionNatures !== undefined) {
                localVarQueryParameter['directionNatures'] = directionNatures;
            }

            if (legalNatures !== undefined) {
                localVarQueryParameter['legalNatures'] = legalNatures;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankTransactionCategoriesApi - functional programming interface
 * @export
 */
export const BankTransactionCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankTransactionCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [onlyLeafs] 
         * @param {string} [directionNatures] 
         * @param {string} [legalNatures] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionCategoriesControllerList(workspaceId: string, onlyLeafs?: boolean, directionNatures?: string, legalNatures?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankTransactionCategoryEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionCategoriesControllerList(workspaceId, onlyLeafs, directionNatures, legalNatures, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionCategoriesApi.bankTransactionCategoriesControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankTransactionCategoriesApi - factory interface
 * @export
 */
export const BankTransactionCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankTransactionCategoriesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {boolean} [onlyLeafs] 
         * @param {string} [directionNatures] 
         * @param {string} [legalNatures] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionCategoriesControllerList(workspaceId: string, onlyLeafs?: boolean, directionNatures?: string, legalNatures?: string, options?: any): AxiosPromise<Array<BankTransactionCategoryEntity>> {
            return localVarFp.bankTransactionCategoriesControllerList(workspaceId, onlyLeafs, directionNatures, legalNatures, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankTransactionCategoriesApi - object-oriented interface
 * @export
 * @class BankTransactionCategoriesApi
 * @extends {BaseAPI}
 */
export class BankTransactionCategoriesApi extends BaseAPI {
    /**
     * 
     * @param {string} workspaceId 
     * @param {boolean} [onlyLeafs] 
     * @param {string} [directionNatures] 
     * @param {string} [legalNatures] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionCategoriesApi
     */
    public bankTransactionCategoriesControllerList(workspaceId: string, onlyLeafs?: boolean, directionNatures?: string, legalNatures?: string, options?: RawAxiosRequestConfig) {
        return BankTransactionCategoriesApiFp(this.configuration).bankTransactionCategoriesControllerList(workspaceId, onlyLeafs, directionNatures, legalNatures, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankTransactionTagsApi - axios parameter creator
 * @export
 */
export const BankTransactionTagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateBankTransactionTagRequestDto} createBankTransactionTagRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionTagsControllerCreate: async (workspaceId: string, createBankTransactionTagRequestDto: CreateBankTransactionTagRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionTagsControllerCreate', 'workspaceId', workspaceId)
            // verify required parameter 'createBankTransactionTagRequestDto' is not null or undefined
            assertParamExists('bankTransactionTagsControllerCreate', 'createBankTransactionTagRequestDto', createBankTransactionTagRequestDto)
            const localVarPath = `/bank/workspaces/{workspaceId}/transaction-tags`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBankTransactionTagRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionTagsControllerList: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionTagsControllerList', 'workspaceId', workspaceId)
            const localVarPath = `/bank/workspaces/{workspaceId}/transaction-tags`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankTransactionTagsApi - functional programming interface
 * @export
 */
export const BankTransactionTagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankTransactionTagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateBankTransactionTagRequestDto} createBankTransactionTagRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionTagsControllerCreate(workspaceId: string, createBankTransactionTagRequestDto: CreateBankTransactionTagRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionTagEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionTagsControllerCreate(workspaceId, createBankTransactionTagRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionTagsApi.bankTransactionTagsControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionTagsControllerList(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankTransactionTagEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionTagsControllerList(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionTagsApi.bankTransactionTagsControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankTransactionTagsApi - factory interface
 * @export
 */
export const BankTransactionTagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankTransactionTagsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateBankTransactionTagRequestDto} createBankTransactionTagRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionTagsControllerCreate(workspaceId: string, createBankTransactionTagRequestDto: CreateBankTransactionTagRequestDto, options?: any): AxiosPromise<BankTransactionTagEntity> {
            return localVarFp.bankTransactionTagsControllerCreate(workspaceId, createBankTransactionTagRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionTagsControllerList(workspaceId: string, options?: any): AxiosPromise<Array<BankTransactionTagEntity>> {
            return localVarFp.bankTransactionTagsControllerList(workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankTransactionTagsApi - object-oriented interface
 * @export
 * @class BankTransactionTagsApi
 * @extends {BaseAPI}
 */
export class BankTransactionTagsApi extends BaseAPI {
    /**
     * 
     * @param {string} workspaceId 
     * @param {CreateBankTransactionTagRequestDto} createBankTransactionTagRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionTagsApi
     */
    public bankTransactionTagsControllerCreate(workspaceId: string, createBankTransactionTagRequestDto: CreateBankTransactionTagRequestDto, options?: RawAxiosRequestConfig) {
        return BankTransactionTagsApiFp(this.configuration).bankTransactionTagsControllerCreate(workspaceId, createBankTransactionTagRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionTagsApi
     */
    public bankTransactionTagsControllerList(workspaceId: string, options?: RawAxiosRequestConfig) {
        return BankTransactionTagsApiFp(this.configuration).bankTransactionTagsControllerList(workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankTransactionsApi - axios parameter creator
 * @export
 */
export const BankTransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateOrUpdateBankTransactionsInBulkRequestDto} createOrUpdateBankTransactionsInBulkRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerCreateOrUpdateInBulk: async (createOrUpdateBankTransactionsInBulkRequestDto: CreateOrUpdateBankTransactionsInBulkRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrUpdateBankTransactionsInBulkRequestDto' is not null or undefined
            assertParamExists('bankTransactionsControllerCreateOrUpdateInBulk', 'createOrUpdateBankTransactionsInBulkRequestDto', createOrUpdateBankTransactionsInBulkRequestDto)
            const localVarPath = `/bank/transactions/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateBankTransactionsInBulkRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetById: async (bankTransactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankTransactionId' is not null or undefined
            assertParamExists('bankTransactionsControllerGetById', 'bankTransactionId', bankTransactionId)
            const localVarPath = `/bank/transactions/{bankTransactionId}`
                .replace(`{${"bankTransactionId"}}`, encodeURIComponent(String(bankTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} provider 
         * @param {string} providerTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetByProvider: async (accountId: string, provider: string, providerTransactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('bankTransactionsControllerGetByProvider', 'accountId', accountId)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('bankTransactionsControllerGetByProvider', 'provider', provider)
            // verify required parameter 'providerTransactionId' is not null or undefined
            assertParamExists('bankTransactionsControllerGetByProvider', 'providerTransactionId', providerTransactionId)
            const localVarPath = `/bank/accounts/{accountId}/transactions/by-provider`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (providerTransactionId !== undefined) {
                localVarQueryParameter['providerTransactionId'] = providerTransactionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {string} [directionNatures] 
         * @param {string} [minPostedDatetime] 
         * @param {string} [maxPostedDatetime] 
         * @param {string} [minCompetencyDatetime] 
         * @param {string} [maxCompetencyDatetime] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [considerAutomaticApplicationRelated] 
         * @param {boolean} [considerInternalTransfers] 
         * @param {string} [considerInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetTotals: async (workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, directionNatures?: string, minPostedDatetime?: string, maxPostedDatetime?: string, minCompetencyDatetime?: string, maxCompetencyDatetime?: string, considerIgnored?: boolean, considerAutomaticApplicationRelated?: boolean, considerInternalTransfers?: boolean, considerInvoiceRelated?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionsControllerGetTotals', 'workspaceId', workspaceId)
            const localVarPath = `/bank/workspaces/{workspaceId}/transactions/totals`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (categoryIds !== undefined) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (tagIds !== undefined) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (legalNatures !== undefined) {
                localVarQueryParameter['legalNatures'] = legalNatures;
            }

            if (directionNatures !== undefined) {
                localVarQueryParameter['directionNatures'] = directionNatures;
            }

            if (minPostedDatetime !== undefined) {
                localVarQueryParameter['minPostedDatetime'] = minPostedDatetime;
            }

            if (maxPostedDatetime !== undefined) {
                localVarQueryParameter['maxPostedDatetime'] = maxPostedDatetime;
            }

            if (minCompetencyDatetime !== undefined) {
                localVarQueryParameter['minCompetencyDatetime'] = minCompetencyDatetime;
            }

            if (maxCompetencyDatetime !== undefined) {
                localVarQueryParameter['maxCompetencyDatetime'] = maxCompetencyDatetime;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (considerAutomaticApplicationRelated !== undefined) {
                localVarQueryParameter['considerAutomaticApplicationRelated'] = considerAutomaticApplicationRelated;
            }

            if (considerInternalTransfers !== undefined) {
                localVarQueryParameter['considerInternalTransfers'] = considerInternalTransfers;
            }

            if (considerInvoiceRelated !== undefined) {
                localVarQueryParameter['considerInvoiceRelated'] = considerInvoiceRelated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {string} [directionNatures] 
         * @param {string} [minPostedDatetime] 
         * @param {string} [maxPostedDatetime] 
         * @param {string} [minCompetencyDatetime] 
         * @param {string} [maxCompetencyDatetime] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [considerAutomaticApplicationRelated] 
         * @param {boolean} [considerInternalTransfers] 
         * @param {string} [considerInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerList: async (workspaceId: string, pageIndex?: number, pageSize?: number, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, directionNatures?: string, minPostedDatetime?: string, maxPostedDatetime?: string, minCompetencyDatetime?: string, maxCompetencyDatetime?: string, considerIgnored?: boolean, considerAutomaticApplicationRelated?: boolean, considerInternalTransfers?: boolean, considerInvoiceRelated?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionsControllerList', 'workspaceId', workspaceId)
            const localVarPath = `/bank/workspaces/{workspaceId}/transactions`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (categoryIds !== undefined) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (tagIds !== undefined) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (legalNatures !== undefined) {
                localVarQueryParameter['legalNatures'] = legalNatures;
            }

            if (directionNatures !== undefined) {
                localVarQueryParameter['directionNatures'] = directionNatures;
            }

            if (minPostedDatetime !== undefined) {
                localVarQueryParameter['minPostedDatetime'] = minPostedDatetime;
            }

            if (maxPostedDatetime !== undefined) {
                localVarQueryParameter['maxPostedDatetime'] = maxPostedDatetime;
            }

            if (minCompetencyDatetime !== undefined) {
                localVarQueryParameter['minCompetencyDatetime'] = minCompetencyDatetime;
            }

            if (maxCompetencyDatetime !== undefined) {
                localVarQueryParameter['maxCompetencyDatetime'] = maxCompetencyDatetime;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (considerAutomaticApplicationRelated !== undefined) {
                localVarQueryParameter['considerAutomaticApplicationRelated'] = considerAutomaticApplicationRelated;
            }

            if (considerInternalTransfers !== undefined) {
                localVarQueryParameter['considerInternalTransfers'] = considerInternalTransfers;
            }

            if (considerInvoiceRelated !== undefined) {
                localVarQueryParameter['considerInvoiceRelated'] = considerInvoiceRelated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerListMostRecent: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionsControllerListMostRecent', 'workspaceId', workspaceId)
            const localVarPath = `/bank/workspaces/{workspaceId}/transactions/most-recent`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {boolean} [considerIgnored] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerListNotVerified: async (workspaceId: string, pageIndex?: number, pageSize?: number, considerIgnored?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionsControllerListNotVerified', 'workspaceId', workspaceId)
            const localVarPath = `/bank/workspaces/{workspaceId}/transactions/not-verified`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} fromDatetime 
         * @param {string} toDatetime 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerListVerifiedByMe: async (workspaceId: string, fromDatetime: string, toDatetime: string, pageIndex?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('bankTransactionsControllerListVerifiedByMe', 'workspaceId', workspaceId)
            // verify required parameter 'fromDatetime' is not null or undefined
            assertParamExists('bankTransactionsControllerListVerifiedByMe', 'fromDatetime', fromDatetime)
            // verify required parameter 'toDatetime' is not null or undefined
            assertParamExists('bankTransactionsControllerListVerifiedByMe', 'toDatetime', toDatetime)
            const localVarPath = `/bank/workspaces/{workspaceId}/transactions/verified-by-me`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromDatetime !== undefined) {
                localVarQueryParameter['fromDatetime'] = fromDatetime;
            }

            if (toDatetime !== undefined) {
                localVarQueryParameter['toDatetime'] = toDatetime;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {PartialUpdateBankTransactionRequestDto} partialUpdateBankTransactionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerPartialUpdate: async (bankTransactionId: string, partialUpdateBankTransactionRequestDto: PartialUpdateBankTransactionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankTransactionId' is not null or undefined
            assertParamExists('bankTransactionsControllerPartialUpdate', 'bankTransactionId', bankTransactionId)
            // verify required parameter 'partialUpdateBankTransactionRequestDto' is not null or undefined
            assertParamExists('bankTransactionsControllerPartialUpdate', 'partialUpdateBankTransactionRequestDto', partialUpdateBankTransactionRequestDto)
            const localVarPath = `/bank/transactions/{bankTransactionId}`
                .replace(`{${"bankTransactionId"}}`, encodeURIComponent(String(bankTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partialUpdateBankTransactionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankTransactionsApi - functional programming interface
 * @export
 */
export const BankTransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankTransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateOrUpdateBankTransactionsInBulkRequestDto} createOrUpdateBankTransactionsInBulkRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerCreateOrUpdateInBulk(createOrUpdateBankTransactionsInBulkRequestDto: CreateOrUpdateBankTransactionsInBulkRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankTransactionEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerCreateOrUpdateInBulk(createOrUpdateBankTransactionsInBulkRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerCreateOrUpdateInBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerGetById(bankTransactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerGetById(bankTransactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} provider 
         * @param {string} providerTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerGetByProvider(accountId: string, provider: string, providerTransactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerGetByProvider(accountId, provider, providerTransactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerGetByProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {string} [directionNatures] 
         * @param {string} [minPostedDatetime] 
         * @param {string} [maxPostedDatetime] 
         * @param {string} [minCompetencyDatetime] 
         * @param {string} [maxCompetencyDatetime] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [considerAutomaticApplicationRelated] 
         * @param {boolean} [considerInternalTransfers] 
         * @param {string} [considerInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerGetTotals(workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, directionNatures?: string, minPostedDatetime?: string, maxPostedDatetime?: string, minCompetencyDatetime?: string, maxCompetencyDatetime?: string, considerIgnored?: boolean, considerAutomaticApplicationRelated?: boolean, considerInternalTransfers?: boolean, considerInvoiceRelated?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionsPageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerGetTotals(workspaceId, accountIds, categoryIds, tagIds, legalNatures, directionNatures, minPostedDatetime, maxPostedDatetime, minCompetencyDatetime, maxCompetencyDatetime, considerIgnored, considerAutomaticApplicationRelated, considerInternalTransfers, considerInvoiceRelated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerGetTotals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {string} [directionNatures] 
         * @param {string} [minPostedDatetime] 
         * @param {string} [maxPostedDatetime] 
         * @param {string} [minCompetencyDatetime] 
         * @param {string} [maxCompetencyDatetime] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [considerAutomaticApplicationRelated] 
         * @param {boolean} [considerInternalTransfers] 
         * @param {string} [considerInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerList(workspaceId: string, pageIndex?: number, pageSize?: number, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, directionNatures?: string, minPostedDatetime?: string, maxPostedDatetime?: string, minCompetencyDatetime?: string, maxCompetencyDatetime?: string, considerIgnored?: boolean, considerAutomaticApplicationRelated?: boolean, considerInternalTransfers?: boolean, considerInvoiceRelated?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionsPageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerList(workspaceId, pageIndex, pageSize, accountIds, categoryIds, tagIds, legalNatures, directionNatures, minPostedDatetime, maxPostedDatetime, minCompetencyDatetime, maxCompetencyDatetime, considerIgnored, considerAutomaticApplicationRelated, considerInternalTransfers, considerInvoiceRelated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerListMostRecent(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankTransactionEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerListMostRecent(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerListMostRecent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {boolean} [considerIgnored] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerListNotVerified(workspaceId: string, pageIndex?: number, pageSize?: number, considerIgnored?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionsPageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerListNotVerified(workspaceId, pageIndex, pageSize, considerIgnored, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerListNotVerified']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} fromDatetime 
         * @param {string} toDatetime 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerListVerifiedByMe(workspaceId: string, fromDatetime: string, toDatetime: string, pageIndex?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionsPageEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerListVerifiedByMe(workspaceId, fromDatetime, toDatetime, pageIndex, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerListVerifiedByMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {PartialUpdateBankTransactionRequestDto} partialUpdateBankTransactionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsControllerPartialUpdate(bankTransactionId: string, partialUpdateBankTransactionRequestDto: PartialUpdateBankTransactionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransactionEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsControllerPartialUpdate(bankTransactionId, partialUpdateBankTransactionRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsApi.bankTransactionsControllerPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankTransactionsApi - factory interface
 * @export
 */
export const BankTransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankTransactionsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateOrUpdateBankTransactionsInBulkRequestDto} createOrUpdateBankTransactionsInBulkRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerCreateOrUpdateInBulk(createOrUpdateBankTransactionsInBulkRequestDto: CreateOrUpdateBankTransactionsInBulkRequestDto, options?: any): AxiosPromise<Array<BankTransactionEntity>> {
            return localVarFp.bankTransactionsControllerCreateOrUpdateInBulk(createOrUpdateBankTransactionsInBulkRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetById(bankTransactionId: string, options?: any): AxiosPromise<BankTransactionEntity> {
            return localVarFp.bankTransactionsControllerGetById(bankTransactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {string} provider 
         * @param {string} providerTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetByProvider(accountId: string, provider: string, providerTransactionId: string, options?: any): AxiosPromise<BankTransactionEntity> {
            return localVarFp.bankTransactionsControllerGetByProvider(accountId, provider, providerTransactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {string} [directionNatures] 
         * @param {string} [minPostedDatetime] 
         * @param {string} [maxPostedDatetime] 
         * @param {string} [minCompetencyDatetime] 
         * @param {string} [maxCompetencyDatetime] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [considerAutomaticApplicationRelated] 
         * @param {boolean} [considerInternalTransfers] 
         * @param {string} [considerInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerGetTotals(workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, directionNatures?: string, minPostedDatetime?: string, maxPostedDatetime?: string, minCompetencyDatetime?: string, maxCompetencyDatetime?: string, considerIgnored?: boolean, considerAutomaticApplicationRelated?: boolean, considerInternalTransfers?: boolean, considerInvoiceRelated?: string, options?: any): AxiosPromise<BankTransactionsPageEntity> {
            return localVarFp.bankTransactionsControllerGetTotals(workspaceId, accountIds, categoryIds, tagIds, legalNatures, directionNatures, minPostedDatetime, maxPostedDatetime, minCompetencyDatetime, maxCompetencyDatetime, considerIgnored, considerAutomaticApplicationRelated, considerInternalTransfers, considerInvoiceRelated, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {string} [directionNatures] 
         * @param {string} [minPostedDatetime] 
         * @param {string} [maxPostedDatetime] 
         * @param {string} [minCompetencyDatetime] 
         * @param {string} [maxCompetencyDatetime] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [considerAutomaticApplicationRelated] 
         * @param {boolean} [considerInternalTransfers] 
         * @param {string} [considerInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerList(workspaceId: string, pageIndex?: number, pageSize?: number, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, directionNatures?: string, minPostedDatetime?: string, maxPostedDatetime?: string, minCompetencyDatetime?: string, maxCompetencyDatetime?: string, considerIgnored?: boolean, considerAutomaticApplicationRelated?: boolean, considerInternalTransfers?: boolean, considerInvoiceRelated?: string, options?: any): AxiosPromise<BankTransactionsPageEntity> {
            return localVarFp.bankTransactionsControllerList(workspaceId, pageIndex, pageSize, accountIds, categoryIds, tagIds, legalNatures, directionNatures, minPostedDatetime, maxPostedDatetime, minCompetencyDatetime, maxCompetencyDatetime, considerIgnored, considerAutomaticApplicationRelated, considerInternalTransfers, considerInvoiceRelated, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerListMostRecent(workspaceId: string, options?: any): AxiosPromise<Array<BankTransactionEntity>> {
            return localVarFp.bankTransactionsControllerListMostRecent(workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {boolean} [considerIgnored] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerListNotVerified(workspaceId: string, pageIndex?: number, pageSize?: number, considerIgnored?: boolean, options?: any): AxiosPromise<BankTransactionsPageEntity> {
            return localVarFp.bankTransactionsControllerListNotVerified(workspaceId, pageIndex, pageSize, considerIgnored, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} fromDatetime 
         * @param {string} toDatetime 
         * @param {number} [pageIndex] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerListVerifiedByMe(workspaceId: string, fromDatetime: string, toDatetime: string, pageIndex?: number, pageSize?: number, options?: any): AxiosPromise<BankTransactionsPageEntity> {
            return localVarFp.bankTransactionsControllerListVerifiedByMe(workspaceId, fromDatetime, toDatetime, pageIndex, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} bankTransactionId 
         * @param {PartialUpdateBankTransactionRequestDto} partialUpdateBankTransactionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsControllerPartialUpdate(bankTransactionId: string, partialUpdateBankTransactionRequestDto: PartialUpdateBankTransactionRequestDto, options?: any): AxiosPromise<BankTransactionEntity> {
            return localVarFp.bankTransactionsControllerPartialUpdate(bankTransactionId, partialUpdateBankTransactionRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankTransactionsApi - object-oriented interface
 * @export
 * @class BankTransactionsApi
 * @extends {BaseAPI}
 */
export class BankTransactionsApi extends BaseAPI {
    /**
     * 
     * @param {CreateOrUpdateBankTransactionsInBulkRequestDto} createOrUpdateBankTransactionsInBulkRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerCreateOrUpdateInBulk(createOrUpdateBankTransactionsInBulkRequestDto: CreateOrUpdateBankTransactionsInBulkRequestDto, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerCreateOrUpdateInBulk(createOrUpdateBankTransactionsInBulkRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankTransactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerGetById(bankTransactionId: string, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerGetById(bankTransactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {string} provider 
     * @param {string} providerTransactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerGetByProvider(accountId: string, provider: string, providerTransactionId: string, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerGetByProvider(accountId, provider, providerTransactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [categoryIds] 
     * @param {string} [tagIds] 
     * @param {string} [legalNatures] 
     * @param {string} [directionNatures] 
     * @param {string} [minPostedDatetime] 
     * @param {string} [maxPostedDatetime] 
     * @param {string} [minCompetencyDatetime] 
     * @param {string} [maxCompetencyDatetime] 
     * @param {boolean} [considerIgnored] 
     * @param {boolean} [considerAutomaticApplicationRelated] 
     * @param {boolean} [considerInternalTransfers] 
     * @param {string} [considerInvoiceRelated] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerGetTotals(workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, directionNatures?: string, minPostedDatetime?: string, maxPostedDatetime?: string, minCompetencyDatetime?: string, maxCompetencyDatetime?: string, considerIgnored?: boolean, considerAutomaticApplicationRelated?: boolean, considerInternalTransfers?: boolean, considerInvoiceRelated?: string, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerGetTotals(workspaceId, accountIds, categoryIds, tagIds, legalNatures, directionNatures, minPostedDatetime, maxPostedDatetime, minCompetencyDatetime, maxCompetencyDatetime, considerIgnored, considerAutomaticApplicationRelated, considerInternalTransfers, considerInvoiceRelated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {string} [accountIds] 
     * @param {string} [categoryIds] 
     * @param {string} [tagIds] 
     * @param {string} [legalNatures] 
     * @param {string} [directionNatures] 
     * @param {string} [minPostedDatetime] 
     * @param {string} [maxPostedDatetime] 
     * @param {string} [minCompetencyDatetime] 
     * @param {string} [maxCompetencyDatetime] 
     * @param {boolean} [considerIgnored] 
     * @param {boolean} [considerAutomaticApplicationRelated] 
     * @param {boolean} [considerInternalTransfers] 
     * @param {string} [considerInvoiceRelated] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerList(workspaceId: string, pageIndex?: number, pageSize?: number, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, directionNatures?: string, minPostedDatetime?: string, maxPostedDatetime?: string, minCompetencyDatetime?: string, maxCompetencyDatetime?: string, considerIgnored?: boolean, considerAutomaticApplicationRelated?: boolean, considerInternalTransfers?: boolean, considerInvoiceRelated?: string, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerList(workspaceId, pageIndex, pageSize, accountIds, categoryIds, tagIds, legalNatures, directionNatures, minPostedDatetime, maxPostedDatetime, minCompetencyDatetime, maxCompetencyDatetime, considerIgnored, considerAutomaticApplicationRelated, considerInternalTransfers, considerInvoiceRelated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerListMostRecent(workspaceId: string, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerListMostRecent(workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {boolean} [considerIgnored] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerListNotVerified(workspaceId: string, pageIndex?: number, pageSize?: number, considerIgnored?: boolean, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerListNotVerified(workspaceId, pageIndex, pageSize, considerIgnored, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} fromDatetime 
     * @param {string} toDatetime 
     * @param {number} [pageIndex] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerListVerifiedByMe(workspaceId: string, fromDatetime: string, toDatetime: string, pageIndex?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerListVerifiedByMe(workspaceId, fromDatetime, toDatetime, pageIndex, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} bankTransactionId 
     * @param {PartialUpdateBankTransactionRequestDto} partialUpdateBankTransactionRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsApi
     */
    public bankTransactionsControllerPartialUpdate(bankTransactionId: string, partialUpdateBankTransactionRequestDto: PartialUpdateBankTransactionRequestDto, options?: RawAxiosRequestConfig) {
        return BankTransactionsApiFp(this.configuration).bankTransactionsControllerPartialUpdate(bankTransactionId, partialUpdateBankTransactionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankTransactionsPageCategoryAssignerApi - axios parameter creator
 * @export
 */
export const BankTransactionsPageCategoryAssignerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AssignCategoryForBankTransactionsPageRequestDto} assignCategoryForBankTransactionsPageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsPageCategoryAssignerControllerAssign: async (assignCategoryForBankTransactionsPageRequestDto: AssignCategoryForBankTransactionsPageRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignCategoryForBankTransactionsPageRequestDto' is not null or undefined
            assertParamExists('bankTransactionsPageCategoryAssignerControllerAssign', 'assignCategoryForBankTransactionsPageRequestDto', assignCategoryForBankTransactionsPageRequestDto)
            const localVarPath = `/bank/transactions/page/category/assign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignCategoryForBankTransactionsPageRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankTransactionsPageCategoryAssignerApi - functional programming interface
 * @export
 */
export const BankTransactionsPageCategoryAssignerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankTransactionsPageCategoryAssignerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AssignCategoryForBankTransactionsPageRequestDto} assignCategoryForBankTransactionsPageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsPageCategoryAssignerControllerAssign(assignCategoryForBankTransactionsPageRequestDto: AssignCategoryForBankTransactionsPageRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsPageCategoryAssignerControllerAssign(assignCategoryForBankTransactionsPageRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsPageCategoryAssignerApi.bankTransactionsPageCategoryAssignerControllerAssign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankTransactionsPageCategoryAssignerApi - factory interface
 * @export
 */
export const BankTransactionsPageCategoryAssignerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankTransactionsPageCategoryAssignerApiFp(configuration)
    return {
        /**
         * 
         * @param {AssignCategoryForBankTransactionsPageRequestDto} assignCategoryForBankTransactionsPageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsPageCategoryAssignerControllerAssign(assignCategoryForBankTransactionsPageRequestDto: AssignCategoryForBankTransactionsPageRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.bankTransactionsPageCategoryAssignerControllerAssign(assignCategoryForBankTransactionsPageRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankTransactionsPageCategoryAssignerApi - object-oriented interface
 * @export
 * @class BankTransactionsPageCategoryAssignerApi
 * @extends {BaseAPI}
 */
export class BankTransactionsPageCategoryAssignerApi extends BaseAPI {
    /**
     * 
     * @param {AssignCategoryForBankTransactionsPageRequestDto} assignCategoryForBankTransactionsPageRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsPageCategoryAssignerApi
     */
    public bankTransactionsPageCategoryAssignerControllerAssign(assignCategoryForBankTransactionsPageRequestDto: AssignCategoryForBankTransactionsPageRequestDto, options?: RawAxiosRequestConfig) {
        return BankTransactionsPageCategoryAssignerApiFp(this.configuration).bankTransactionsPageCategoryAssignerControllerAssign(assignCategoryForBankTransactionsPageRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankTransactionsPageLegalNatureAssignerApi - axios parameter creator
 * @export
 */
export const BankTransactionsPageLegalNatureAssignerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AssignLegalNatureForBankTransactionsPageRequestDto} assignLegalNatureForBankTransactionsPageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsPageLegalNatureAssignerControllerAssign: async (assignLegalNatureForBankTransactionsPageRequestDto: AssignLegalNatureForBankTransactionsPageRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignLegalNatureForBankTransactionsPageRequestDto' is not null or undefined
            assertParamExists('bankTransactionsPageLegalNatureAssignerControllerAssign', 'assignLegalNatureForBankTransactionsPageRequestDto', assignLegalNatureForBankTransactionsPageRequestDto)
            const localVarPath = `/bank/transactions/page/legal-nature/assign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignLegalNatureForBankTransactionsPageRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankTransactionsPageLegalNatureAssignerApi - functional programming interface
 * @export
 */
export const BankTransactionsPageLegalNatureAssignerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankTransactionsPageLegalNatureAssignerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AssignLegalNatureForBankTransactionsPageRequestDto} assignLegalNatureForBankTransactionsPageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankTransactionsPageLegalNatureAssignerControllerAssign(assignLegalNatureForBankTransactionsPageRequestDto: AssignLegalNatureForBankTransactionsPageRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTransactionsPageLegalNatureAssignerControllerAssign(assignLegalNatureForBankTransactionsPageRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransactionsPageLegalNatureAssignerApi.bankTransactionsPageLegalNatureAssignerControllerAssign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankTransactionsPageLegalNatureAssignerApi - factory interface
 * @export
 */
export const BankTransactionsPageLegalNatureAssignerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankTransactionsPageLegalNatureAssignerApiFp(configuration)
    return {
        /**
         * 
         * @param {AssignLegalNatureForBankTransactionsPageRequestDto} assignLegalNatureForBankTransactionsPageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankTransactionsPageLegalNatureAssignerControllerAssign(assignLegalNatureForBankTransactionsPageRequestDto: AssignLegalNatureForBankTransactionsPageRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.bankTransactionsPageLegalNatureAssignerControllerAssign(assignLegalNatureForBankTransactionsPageRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankTransactionsPageLegalNatureAssignerApi - object-oriented interface
 * @export
 * @class BankTransactionsPageLegalNatureAssignerApi
 * @extends {BaseAPI}
 */
export class BankTransactionsPageLegalNatureAssignerApi extends BaseAPI {
    /**
     * 
     * @param {AssignLegalNatureForBankTransactionsPageRequestDto} assignLegalNatureForBankTransactionsPageRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransactionsPageLegalNatureAssignerApi
     */
    public bankTransactionsPageLegalNatureAssignerControllerAssign(assignLegalNatureForBankTransactionsPageRequestDto: AssignLegalNatureForBankTransactionsPageRequestDto, options?: RawAxiosRequestConfig) {
        return BankTransactionsPageLegalNatureAssignerApiFp(this.configuration).bankTransactionsPageLegalNatureAssignerControllerAssign(assignLegalNatureForBankTransactionsPageRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelloApi - axios parameter creator
 * @export
 */
export const HelloApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloControllerHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hello`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelloApi - functional programming interface
 * @export
 */
export const HelloApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelloApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helloControllerHello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helloControllerHello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelloApi.helloControllerHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelloApi - factory interface
 * @export
 */
export const HelloApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelloApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloControllerHello(options?: any): AxiosPromise<void> {
            return localVarFp.helloControllerHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelloApi - object-oriented interface
 * @export
 * @class HelloApi
 * @extends {BaseAPI}
 */
export class HelloApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelloApi
     */
    public helloControllerHello(options?: RawAxiosRequestConfig) {
        return HelloApiFp(this.configuration).helloControllerHello(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessageTokensApi - axios parameter creator
 * @export
 */
export const MessageTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateMessageTokenRequestDto} createOrUpdateMessageTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTokensControllerCreateOrUpdate: async (workspaceId: string, createOrUpdateMessageTokenRequestDto: CreateOrUpdateMessageTokenRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('messageTokensControllerCreateOrUpdate', 'workspaceId', workspaceId)
            // verify required parameter 'createOrUpdateMessageTokenRequestDto' is not null or undefined
            assertParamExists('messageTokensControllerCreateOrUpdate', 'createOrUpdateMessageTokenRequestDto', createOrUpdateMessageTokenRequestDto)
            const localVarPath = `/communication/workspaces/{workspaceId}/message-tokens`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateMessageTokenRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTokensControllerListByWorkspaceId: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('messageTokensControllerListByWorkspaceId', 'workspaceId', workspaceId)
            const localVarPath = `/communication/workspaces/{workspaceId}/message-tokens`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageTokensApi - functional programming interface
 * @export
 */
export const MessageTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateMessageTokenRequestDto} createOrUpdateMessageTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageTokensControllerCreateOrUpdate(workspaceId: string, createOrUpdateMessageTokenRequestDto: CreateOrUpdateMessageTokenRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageTokenEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageTokensControllerCreateOrUpdate(workspaceId, createOrUpdateMessageTokenRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageTokensApi.messageTokensControllerCreateOrUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageTokensControllerListByWorkspaceId(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageTokenEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messageTokensControllerListByWorkspaceId(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageTokensApi.messageTokensControllerListByWorkspaceId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessageTokensApi - factory interface
 * @export
 */
export const MessageTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageTokensApiFp(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {CreateOrUpdateMessageTokenRequestDto} createOrUpdateMessageTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTokensControllerCreateOrUpdate(workspaceId: string, createOrUpdateMessageTokenRequestDto: CreateOrUpdateMessageTokenRequestDto, options?: any): AxiosPromise<MessageTokenEntity> {
            return localVarFp.messageTokensControllerCreateOrUpdate(workspaceId, createOrUpdateMessageTokenRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageTokensControllerListByWorkspaceId(workspaceId: string, options?: any): AxiosPromise<Array<MessageTokenEntity>> {
            return localVarFp.messageTokensControllerListByWorkspaceId(workspaceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageTokensApi - object-oriented interface
 * @export
 * @class MessageTokensApi
 * @extends {BaseAPI}
 */
export class MessageTokensApi extends BaseAPI {
    /**
     * 
     * @param {string} workspaceId 
     * @param {CreateOrUpdateMessageTokenRequestDto} createOrUpdateMessageTokenRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageTokensApi
     */
    public messageTokensControllerCreateOrUpdate(workspaceId: string, createOrUpdateMessageTokenRequestDto: CreateOrUpdateMessageTokenRequestDto, options?: RawAxiosRequestConfig) {
        return MessageTokensApiFp(this.configuration).messageTokensControllerCreateOrUpdate(workspaceId, createOrUpdateMessageTokenRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageTokensApi
     */
    public messageTokensControllerListByWorkspaceId(workspaceId: string, options?: RawAxiosRequestConfig) {
        return MessageTokensApiFp(this.configuration).messageTokensControllerListByWorkspaceId(workspaceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PluggyApi - axios parameter creator
 * @export
 */
export const PluggyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePluggyConnectTokenRequestDto} createPluggyConnectTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluggyControllerCreateConnectToken: async (createPluggyConnectTokenRequestDto: CreatePluggyConnectTokenRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPluggyConnectTokenRequestDto' is not null or undefined
            assertParamExists('pluggyControllerCreateConnectToken', 'createPluggyConnectTokenRequestDto', createPluggyConnectTokenRequestDto)
            const localVarPath = `/pluggy/connect-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPluggyConnectTokenRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluggyControllerWebhook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pluggy/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluggyApi - functional programming interface
 * @export
 */
export const PluggyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PluggyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreatePluggyConnectTokenRequestDto} createPluggyConnectTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluggyControllerCreateConnectToken(createPluggyConnectTokenRequestDto: CreatePluggyConnectTokenRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluggyConnectTokenEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluggyControllerCreateConnectToken(createPluggyConnectTokenRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluggyApi.pluggyControllerCreateConnectToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluggyControllerWebhook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pluggyControllerWebhook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluggyApi.pluggyControllerWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PluggyApi - factory interface
 * @export
 */
export const PluggyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PluggyApiFp(configuration)
    return {
        /**
         * 
         * @param {CreatePluggyConnectTokenRequestDto} createPluggyConnectTokenRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluggyControllerCreateConnectToken(createPluggyConnectTokenRequestDto: CreatePluggyConnectTokenRequestDto, options?: any): AxiosPromise<PluggyConnectTokenEntity> {
            return localVarFp.pluggyControllerCreateConnectToken(createPluggyConnectTokenRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluggyControllerWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.pluggyControllerWebhook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluggyApi - object-oriented interface
 * @export
 * @class PluggyApi
 * @extends {BaseAPI}
 */
export class PluggyApi extends BaseAPI {
    /**
     * 
     * @param {CreatePluggyConnectTokenRequestDto} createPluggyConnectTokenRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluggyApi
     */
    public pluggyControllerCreateConnectToken(createPluggyConnectTokenRequestDto: CreatePluggyConnectTokenRequestDto, options?: RawAxiosRequestConfig) {
        return PluggyApiFp(this.configuration).pluggyControllerCreateConnectToken(createPluggyConnectTokenRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluggyApi
     */
    public pluggyControllerWebhook(options?: RawAxiosRequestConfig) {
        return PluggyApiFp(this.configuration).pluggyControllerWebhook(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProfileRequestDto} createProfileRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerCreate: async (createProfileRequestDto: CreateProfileRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProfileRequestDto' is not null or undefined
            assertParamExists('profilesControllerCreate', 'createProfileRequestDto', createProfileRequestDto)
            const localVarPath = `/iam/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProfileRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerGetMy: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/profiles/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PartialUpdateProfileRequestDto} partialUpdateProfileRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerPartialUpdate: async (partialUpdateProfileRequestDto: PartialUpdateProfileRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partialUpdateProfileRequestDto' is not null or undefined
            assertParamExists('profilesControllerPartialUpdate', 'partialUpdateProfileRequestDto', partialUpdateProfileRequestDto)
            const localVarPath = `/iam/profiles/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partialUpdateProfileRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProfileRequestDto} createProfileRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesControllerCreate(createProfileRequestDto: CreateProfileRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesControllerCreate(createProfileRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.profilesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesControllerGetMy(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesControllerGetMy(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.profilesControllerGetMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PartialUpdateProfileRequestDto} partialUpdateProfileRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilesControllerPartialUpdate(partialUpdateProfileRequestDto: PartialUpdateProfileRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilesControllerPartialUpdate(partialUpdateProfileRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.profilesControllerPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProfileRequestDto} createProfileRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerCreate(createProfileRequestDto: CreateProfileRequestDto, options?: any): AxiosPromise<ProfileEntity> {
            return localVarFp.profilesControllerCreate(createProfileRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerGetMy(options?: any): AxiosPromise<ProfileEntity> {
            return localVarFp.profilesControllerGetMy(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PartialUpdateProfileRequestDto} partialUpdateProfileRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilesControllerPartialUpdate(partialUpdateProfileRequestDto: PartialUpdateProfileRequestDto, options?: any): AxiosPromise<ProfileEntity> {
            return localVarFp.profilesControllerPartialUpdate(partialUpdateProfileRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
    /**
     * 
     * @param {CreateProfileRequestDto} createProfileRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesControllerCreate(createProfileRequestDto: CreateProfileRequestDto, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesControllerCreate(createProfileRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesControllerGetMy(options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesControllerGetMy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PartialUpdateProfileRequestDto} partialUpdateProfileRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public profilesControllerPartialUpdate(partialUpdateProfileRequestDto: PartialUpdateProfileRequestDto, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).profilesControllerPartialUpdate(partialUpdateProfileRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {boolean} [ignoreAutomaticApplicationRelated] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetAccountsEntriesByCategoryReport: async (workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetAccountsEntriesByCategoryReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/accounts/entries-by-category`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (tagIds !== undefined) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (legalNatures !== undefined) {
                localVarQueryParameter['legalNatures'] = legalNatures;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (ignoreInternalTransfers !== undefined) {
                localVarQueryParameter['ignoreInternalTransfers'] = ignoreInternalTransfers;
            }

            if (ignoreAutomaticApplicationRelated !== undefined) {
                localVarQueryParameter['ignoreAutomaticApplicationRelated'] = ignoreAutomaticApplicationRelated;
            }

            if (minPostedDate !== undefined) {
                localVarQueryParameter['minPostedDate'] = minPostedDate;
            }

            if (maxPostedDate !== undefined) {
                localVarQueryParameter['maxPostedDate'] = maxPostedDate;
            }

            if (minCompetencyDate !== undefined) {
                localVarQueryParameter['minCompetencyDate'] = minCompetencyDate;
            }

            if (maxCompetencyDate !== undefined) {
                localVarQueryParameter['maxCompetencyDate'] = maxCompetencyDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {boolean} [ignoreAutomaticApplicationRelated] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetAccountsOutputsByCategoryReport: async (workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetAccountsOutputsByCategoryReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/accounts/outputs-by-category`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (tagIds !== undefined) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (legalNatures !== undefined) {
                localVarQueryParameter['legalNatures'] = legalNatures;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (ignoreInternalTransfers !== undefined) {
                localVarQueryParameter['ignoreInternalTransfers'] = ignoreInternalTransfers;
            }

            if (ignoreAutomaticApplicationRelated !== undefined) {
                localVarQueryParameter['ignoreAutomaticApplicationRelated'] = ignoreAutomaticApplicationRelated;
            }

            if (minPostedDate !== undefined) {
                localVarQueryParameter['minPostedDate'] = minPostedDate;
            }

            if (maxPostedDate !== undefined) {
                localVarQueryParameter['maxPostedDate'] = maxPostedDate;
            }

            if (minCompetencyDate !== undefined) {
                localVarQueryParameter['minCompetencyDate'] = minCompetencyDate;
            }

            if (maxCompetencyDate !== undefined) {
                localVarQueryParameter['maxCompetencyDate'] = maxCompetencyDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetBusinessIndicators: async (workspaceId: string, accountIds?: string, tagIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetBusinessIndicators', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/indicators/business`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (tagIds !== undefined) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (minPostedDate !== undefined) {
                localVarQueryParameter['minPostedDate'] = minPostedDate;
            }

            if (maxPostedDate !== undefined) {
                localVarQueryParameter['maxPostedDate'] = maxPostedDate;
            }

            if (minCompetencyDate !== undefined) {
                localVarQueryParameter['minCompetencyDate'] = minCompetencyDate;
            }

            if (maxCompetencyDate !== undefined) {
                localVarQueryParameter['maxCompetencyDate'] = maxCompetencyDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCardsCashFlowReport: async (workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInvoiceRelated?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetCardsCashFlowReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/cards/cash-flow`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (categoryIds !== undefined) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (tagIds !== undefined) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (legalNatures !== undefined) {
                localVarQueryParameter['legalNatures'] = legalNatures;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (ignoreInvoiceRelated !== undefined) {
                localVarQueryParameter['ignoreInvoiceRelated'] = ignoreInvoiceRelated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCardsOutputsByCategoryReport: async (workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, ignoreInvoiceRelated?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetCardsOutputsByCategoryReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/cards/outputs-by-category`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (tagIds !== undefined) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (legalNatures !== undefined) {
                localVarQueryParameter['legalNatures'] = legalNatures;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (minPostedDate !== undefined) {
                localVarQueryParameter['minPostedDate'] = minPostedDate;
            }

            if (maxPostedDate !== undefined) {
                localVarQueryParameter['maxPostedDate'] = maxPostedDate;
            }

            if (minCompetencyDate !== undefined) {
                localVarQueryParameter['minCompetencyDate'] = minCompetencyDate;
            }

            if (maxCompetencyDate !== undefined) {
                localVarQueryParameter['maxCompetencyDate'] = maxCompetencyDate;
            }

            if (ignoreInvoiceRelated !== undefined) {
                localVarQueryParameter['ignoreInvoiceRelated'] = ignoreInvoiceRelated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {boolean} [ignoreAutomaticApplicationRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCashFlowReport: async (workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetCashFlowReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/accounts/cash-flow`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (categoryIds !== undefined) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (tagIds !== undefined) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (legalNatures !== undefined) {
                localVarQueryParameter['legalNatures'] = legalNatures;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (ignoreInternalTransfers !== undefined) {
                localVarQueryParameter['ignoreInternalTransfers'] = ignoreInternalTransfers;
            }

            if (ignoreAutomaticApplicationRelated !== undefined) {
                localVarQueryParameter['ignoreAutomaticApplicationRelated'] = ignoreAutomaticApplicationRelated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetFinancialStatementReport: async (workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('reportsControllerGetFinancialStatementReport', 'workspaceId', workspaceId)
            const localVarPath = `/workspaces/{workspaceId}/reports/financial-statement`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds !== undefined) {
                localVarQueryParameter['accountIds'] = accountIds;
            }

            if (tagIds !== undefined) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (legalNatures !== undefined) {
                localVarQueryParameter['legalNatures'] = legalNatures;
            }

            if (considerIgnored !== undefined) {
                localVarQueryParameter['considerIgnored'] = considerIgnored;
            }

            if (minPostedDate !== undefined) {
                localVarQueryParameter['minPostedDate'] = minPostedDate;
            }

            if (maxPostedDate !== undefined) {
                localVarQueryParameter['maxPostedDate'] = maxPostedDate;
            }

            if (minCompetencyDate !== undefined) {
                localVarQueryParameter['minCompetencyDate'] = minCompetencyDate;
            }

            if (maxCompetencyDate !== undefined) {
                localVarQueryParameter['maxCompetencyDate'] = maxCompetencyDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {boolean} [ignoreAutomaticApplicationRelated] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetAccountsEntriesByCategoryReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowByCategoryReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetAccountsEntriesByCategoryReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, ignoreInternalTransfers, ignoreAutomaticApplicationRelated, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetAccountsEntriesByCategoryReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {boolean} [ignoreAutomaticApplicationRelated] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetAccountsOutputsByCategoryReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowByCategoryReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetAccountsOutputsByCategoryReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, ignoreInternalTransfers, ignoreAutomaticApplicationRelated, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetAccountsOutputsByCategoryReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetBusinessIndicators(workspaceId: string, accountIds?: string, tagIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankTransactionIndicatorEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetBusinessIndicators(workspaceId, accountIds, tagIds, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetBusinessIndicators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetCardsCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInvoiceRelated?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetCardsCashFlowReport(workspaceId, accountIds, categoryIds, tagIds, legalNatures, considerIgnored, ignoreInvoiceRelated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetCardsCashFlowReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetCardsOutputsByCategoryReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, ignoreInvoiceRelated?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowByCategoryReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetCardsOutputsByCategoryReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, ignoreInvoiceRelated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetCardsOutputsByCategoryReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {boolean} [ignoreAutomaticApplicationRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashFlowReportEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetCashFlowReport(workspaceId, accountIds, categoryIds, tagIds, legalNatures, considerIgnored, ignoreInternalTransfers, ignoreAutomaticApplicationRelated, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetCashFlowReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsControllerGetFinancialStatementReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinancialStatementReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsControllerGetFinancialStatementReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.reportsControllerGetFinancialStatementReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {boolean} [ignoreAutomaticApplicationRelated] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetAccountsEntriesByCategoryReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: any): AxiosPromise<CashFlowByCategoryReportEntity> {
            return localVarFp.reportsControllerGetAccountsEntriesByCategoryReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, ignoreInternalTransfers, ignoreAutomaticApplicationRelated, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {boolean} [ignoreAutomaticApplicationRelated] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetAccountsOutputsByCategoryReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: any): AxiosPromise<CashFlowByCategoryReportEntity> {
            return localVarFp.reportsControllerGetAccountsOutputsByCategoryReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, ignoreInternalTransfers, ignoreAutomaticApplicationRelated, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetBusinessIndicators(workspaceId: string, accountIds?: string, tagIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: any): AxiosPromise<Array<BankTransactionIndicatorEntity>> {
            return localVarFp.reportsControllerGetBusinessIndicators(workspaceId, accountIds, tagIds, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCardsCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInvoiceRelated?: boolean, options?: any): AxiosPromise<CashFlowReportEntity> {
            return localVarFp.reportsControllerGetCardsCashFlowReport(workspaceId, accountIds, categoryIds, tagIds, legalNatures, considerIgnored, ignoreInvoiceRelated, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {boolean} [ignoreInvoiceRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCardsOutputsByCategoryReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, ignoreInvoiceRelated?: boolean, options?: any): AxiosPromise<CashFlowByCategoryReportEntity> {
            return localVarFp.reportsControllerGetCardsOutputsByCategoryReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, ignoreInvoiceRelated, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [categoryIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {boolean} [ignoreInternalTransfers] 
         * @param {boolean} [ignoreAutomaticApplicationRelated] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, options?: any): AxiosPromise<CashFlowReportEntity> {
            return localVarFp.reportsControllerGetCashFlowReport(workspaceId, accountIds, categoryIds, tagIds, legalNatures, considerIgnored, ignoreInternalTransfers, ignoreAutomaticApplicationRelated, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {string} [accountIds] 
         * @param {string} [tagIds] 
         * @param {string} [legalNatures] 
         * @param {boolean} [considerIgnored] 
         * @param {string} [minPostedDate] 
         * @param {string} [maxPostedDate] 
         * @param {string} [minCompetencyDate] 
         * @param {string} [maxCompetencyDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsControllerGetFinancialStatementReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: any): AxiosPromise<FinancialStatementReport> {
            return localVarFp.reportsControllerGetFinancialStatementReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [tagIds] 
     * @param {string} [legalNatures] 
     * @param {boolean} [considerIgnored] 
     * @param {boolean} [ignoreInternalTransfers] 
     * @param {boolean} [ignoreAutomaticApplicationRelated] 
     * @param {string} [minPostedDate] 
     * @param {string} [maxPostedDate] 
     * @param {string} [minCompetencyDate] 
     * @param {string} [maxCompetencyDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetAccountsEntriesByCategoryReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetAccountsEntriesByCategoryReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, ignoreInternalTransfers, ignoreAutomaticApplicationRelated, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [tagIds] 
     * @param {string} [legalNatures] 
     * @param {boolean} [considerIgnored] 
     * @param {boolean} [ignoreInternalTransfers] 
     * @param {boolean} [ignoreAutomaticApplicationRelated] 
     * @param {string} [minPostedDate] 
     * @param {string} [maxPostedDate] 
     * @param {string} [minCompetencyDate] 
     * @param {string} [maxCompetencyDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetAccountsOutputsByCategoryReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetAccountsOutputsByCategoryReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, ignoreInternalTransfers, ignoreAutomaticApplicationRelated, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [tagIds] 
     * @param {boolean} [considerIgnored] 
     * @param {string} [minPostedDate] 
     * @param {string} [maxPostedDate] 
     * @param {string} [minCompetencyDate] 
     * @param {string} [maxCompetencyDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetBusinessIndicators(workspaceId: string, accountIds?: string, tagIds?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetBusinessIndicators(workspaceId, accountIds, tagIds, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [categoryIds] 
     * @param {string} [tagIds] 
     * @param {string} [legalNatures] 
     * @param {boolean} [considerIgnored] 
     * @param {boolean} [ignoreInvoiceRelated] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetCardsCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInvoiceRelated?: boolean, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetCardsCashFlowReport(workspaceId, accountIds, categoryIds, tagIds, legalNatures, considerIgnored, ignoreInvoiceRelated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [tagIds] 
     * @param {string} [legalNatures] 
     * @param {boolean} [considerIgnored] 
     * @param {string} [minPostedDate] 
     * @param {string} [maxPostedDate] 
     * @param {string} [minCompetencyDate] 
     * @param {string} [maxCompetencyDate] 
     * @param {boolean} [ignoreInvoiceRelated] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetCardsOutputsByCategoryReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, ignoreInvoiceRelated?: boolean, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetCardsOutputsByCategoryReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, ignoreInvoiceRelated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [categoryIds] 
     * @param {string} [tagIds] 
     * @param {string} [legalNatures] 
     * @param {boolean} [considerIgnored] 
     * @param {boolean} [ignoreInternalTransfers] 
     * @param {boolean} [ignoreAutomaticApplicationRelated] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetCashFlowReport(workspaceId: string, accountIds?: string, categoryIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, ignoreInternalTransfers?: boolean, ignoreAutomaticApplicationRelated?: boolean, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetCashFlowReport(workspaceId, accountIds, categoryIds, tagIds, legalNatures, considerIgnored, ignoreInternalTransfers, ignoreAutomaticApplicationRelated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {string} [accountIds] 
     * @param {string} [tagIds] 
     * @param {string} [legalNatures] 
     * @param {boolean} [considerIgnored] 
     * @param {string} [minPostedDate] 
     * @param {string} [maxPostedDate] 
     * @param {string} [minCompetencyDate] 
     * @param {string} [maxCompetencyDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsControllerGetFinancialStatementReport(workspaceId: string, accountIds?: string, tagIds?: string, legalNatures?: string, considerIgnored?: boolean, minPostedDate?: string, maxPostedDate?: string, minCompetencyDate?: string, maxCompetencyDate?: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsControllerGetFinancialStatementReport(workspaceId, accountIds, tagIds, legalNatures, considerIgnored, minPostedDate, maxPostedDate, minCompetencyDate, maxCompetencyDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspacesApi - axios parameter creator
 * @export
 */
export const WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateWorkspaceRequestDto} createWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerCreate: async (createWorkspaceRequestDto: CreateWorkspaceRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkspaceRequestDto' is not null or undefined
            assertParamExists('workspacesControllerCreate', 'createWorkspaceRequestDto', createWorkspaceRequestDto)
            const localVarPath = `/iam/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkspaceRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerGetById: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspacesControllerGetById', 'workspaceId', workspaceId)
            const localVarPath = `/iam/workspaces/{workspaceId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerListMy: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/workspaces/my`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {PartialUpdateWorkspaceRequestDto} partialUpdateWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerPartialUpdate: async (workspaceId: string, partialUpdateWorkspaceRequestDto: PartialUpdateWorkspaceRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('workspacesControllerPartialUpdate', 'workspaceId', workspaceId)
            // verify required parameter 'partialUpdateWorkspaceRequestDto' is not null or undefined
            assertParamExists('workspacesControllerPartialUpdate', 'partialUpdateWorkspaceRequestDto', partialUpdateWorkspaceRequestDto)
            const localVarPath = `/iam/workspaces/{workspaceId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(partialUpdateWorkspaceRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateWorkspaceRequestDto} createWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerCreate(createWorkspaceRequestDto: CreateWorkspaceRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllerCreate(createWorkspaceRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerGetById(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllerGetById(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesControllerGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerListMy(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRelatedWorkspaceEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllerListMy(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesControllerListMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {PartialUpdateWorkspaceRequestDto} partialUpdateWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesControllerPartialUpdate(workspaceId: string, partialUpdateWorkspaceRequestDto: PartialUpdateWorkspaceRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesControllerPartialUpdate(workspaceId, partialUpdateWorkspaceRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspacesApi.workspacesControllerPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspacesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateWorkspaceRequestDto} createWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerCreate(createWorkspaceRequestDto: CreateWorkspaceRequestDto, options?: any): AxiosPromise<WorkspaceEntity> {
            return localVarFp.workspacesControllerCreate(createWorkspaceRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerGetById(workspaceId: string, options?: any): AxiosPromise<WorkspaceEntity> {
            return localVarFp.workspacesControllerGetById(workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerListMy(options?: any): AxiosPromise<Array<UserRelatedWorkspaceEntity>> {
            return localVarFp.workspacesControllerListMy(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} workspaceId 
         * @param {PartialUpdateWorkspaceRequestDto} partialUpdateWorkspaceRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesControllerPartialUpdate(workspaceId: string, partialUpdateWorkspaceRequestDto: PartialUpdateWorkspaceRequestDto, options?: any): AxiosPromise<WorkspaceEntity> {
            return localVarFp.workspacesControllerPartialUpdate(workspaceId, partialUpdateWorkspaceRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI {
    /**
     * 
     * @param {CreateWorkspaceRequestDto} createWorkspaceRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesControllerCreate(createWorkspaceRequestDto: CreateWorkspaceRequestDto, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesControllerCreate(createWorkspaceRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesControllerGetById(workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesControllerGetById(workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesControllerListMy(options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesControllerListMy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} workspaceId 
     * @param {PartialUpdateWorkspaceRequestDto} partialUpdateWorkspaceRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesControllerPartialUpdate(workspaceId: string, partialUpdateWorkspaceRequestDto: PartialUpdateWorkspaceRequestDto, options?: RawAxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesControllerPartialUpdate(workspaceId, partialUpdateWorkspaceRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



